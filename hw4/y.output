Terminals unused in grammar

   BOOLEAN


State 59 conflicts: 6 reduce/reduce
State 60 conflicts: 8 shift/reduce
State 130 conflicts: 9 shift/reduce
State 133 conflicts: 8 shift/reduce, 15 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: decl_list funct_def decl_and_def_list

    2 decl_list: decl_list var_decl
    3          | decl_list const_decl
    4          | decl_list funct_decl
    5          | %empty

    6 decl_and_def_list: decl_and_def_list var_decl
    7                  | decl_and_def_list const_decl
    8                  | decl_and_def_list funct_decl
    9                  | decl_and_def_list funct_def
   10                  | %empty

   11 $@1: %empty

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 compound_statement

   13 $@2: %empty

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 compound_statement

   15 $@3: %empty

   16 funct_def: VOID ID L_PAREN R_PAREN $@3 compound_statement

   17 $@4: %empty

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@4 compound_statement

   19 funct_decl: scalar_type ID L_PAREN R_PAREN SEMICOLON
   20           | scalar_type ID L_PAREN parameter_list R_PAREN SEMICOLON
   21           | VOID ID L_PAREN R_PAREN SEMICOLON
   22           | VOID ID L_PAREN parameter_list R_PAREN SEMICOLON

   23 parameter_list: parameter_list COMMA scalar_type ID
   24               | parameter_list COMMA scalar_type array_decl
   25               | scalar_type array_decl
   26               | scalar_type ID

   27 var_decl: scalar_type identifier_list SEMICOLON

   28 identifier_list: identifier_list COMMA ID
   29                | identifier_list COMMA ID ASSIGN_OP logical_expression
   30                | identifier_list COMMA array_decl ASSIGN_OP initial_array
   31                | identifier_list COMMA array_decl
   32                | array_decl ASSIGN_OP initial_array
   33                | array_decl
   34                | ID ASSIGN_OP logical_expression
   35                | ID

   36 initial_array: L_BRACE literal_list R_BRACE

   37 literal_list: literal_list COMMA logical_expression
   38             | logical_expression
   39             | %empty

   40 const_decl: CONST scalar_type const_list SEMICOLON

   41 const_list: const_list COMMA ID ASSIGN_OP literal_const
   42           | ID ASSIGN_OP literal_const

   43 array_decl: ID dim

   44 dim: dim ML_BRACE INT_CONST MR_BRACE
   45    | ML_BRACE INT_CONST MR_BRACE

   46 $@5: %empty

   47 compound_statement: $@5 L_BRACE var_const_stmt_list R_BRACE

   48 var_const_stmt_list: var_const_stmt_list statement
   49                    | var_const_stmt_list var_decl
   50                    | var_const_stmt_list const_decl
   51                    | %empty

   52 statement: compound_statement
   53          | simple_statement
   54          | conditional_statement
   55          | while_statement
   56          | for_statement
   57          | function_invoke_statement
   58          | jump_statement

   59 simple_statement: variable_reference ASSIGN_OP logical_expression SEMICOLON

   60 $@6: %empty

   61 simple_statement: PRINT $@6 logical_expression SEMICOLON
   62                 | READ variable_reference SEMICOLON

   63 conditional_statement: IF L_PAREN conditional_if R_PAREN compound_statement
   64                      | IF L_PAREN conditional_if R_PAREN compound_statement ELSE compound_statement

   65 conditional_if: logical_expression

   66 $@7: %empty

   67 $@8: %empty

   68 while_statement: WHILE L_PAREN logical_expression $@7 R_PAREN $@8 compound_statement

   69 $@9: %empty

   70 while_statement: $@9 DO compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON

   71 $@10: %empty

   72 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@10 compound_statement

   73 initial_expression: initial_expression COMMA statement_for
   74                   | initial_expression COMMA logical_expression
   75                   | logical_expression
   76                   | statement_for
   77                   | %empty

   78 control_expression: control_expression COMMA statement_for
   79                   | control_expression COMMA logical_expression
   80                   | logical_expression
   81                   | statement_for
   82                   | %empty

   83 increment_expression: increment_expression COMMA statement_for
   84                     | increment_expression COMMA logical_expression
   85                     | logical_expression
   86                     | statement_for
   87                     | %empty

   88 statement_for: variable_reference ASSIGN_OP logical_expression

   89 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN SEMICOLON
   90                          | ID L_PAREN R_PAREN SEMICOLON

   91 jump_statement: CONTINUE SEMICOLON
   92               | BREAK SEMICOLON
   93               | RETURN logical_expression SEMICOLON

   94 variable_reference: ID
   95                   | variable_reference dimension

   96 dimension: ML_BRACE arithmetic_expression MR_BRACE

   97 logical_expression: logical_expression OR_OP logical_term
   98                   | logical_term

   99 logical_term: logical_term AND_OP logical_factor
  100             | logical_factor

  101 logical_factor: NOT_OP logical_factor
  102               | relation_expression

  103 relation_expression: arithmetic_expression relation_operator arithmetic_expression
  104                    | arithmetic_expression

  105 relation_operator: LT_OP
  106                  | LE_OP
  107                  | EQ_OP
  108                  | GE_OP
  109                  | GT_OP
  110                  | NE_OP

  111 arithmetic_expression: arithmetic_expression add_op term
  112                      | relation_expression
  113                      | term

  114 add_op: ADD_OP
  115       | SUB_OP

  116 term: term mul_op factor
  117     | factor

  118 mul_op: MUL_OP
  119       | DIV_OP
  120       | MOD_OP

  121 factor: variable_reference
  122       | SUB_OP variable_reference
  123       | L_PAREN logical_expression R_PAREN
  124       | SUB_OP L_PAREN logical_expression R_PAREN
  125       | ID L_PAREN logical_expression_list R_PAREN
  126       | SUB_OP ID L_PAREN logical_expression_list R_PAREN
  127       | ID L_PAREN R_PAREN
  128       | SUB_OP ID L_PAREN R_PAREN
  129       | literal_const

  130 logical_expression_list: logical_expression_list COMMA logical_expression
  131                        | logical_expression

  132 scalar_type: INT
  133            | DOUBLE
  134            | STRING
  135            | BOOL
  136            | FLOAT

  137 literal_const: INT_CONST
  138              | SUB_OP INT_CONST
  139              | FLOAT_CONST
  140              | SUB_OP FLOAT_CONST
  141              | SCIENTIFIC
  142              | SUB_OP SCIENTIFIC
  143              | STR_CONST
  144              | TRUE
  145              | FALSE


Terminals, with rules where they appear

$end (0) 0
error (256)
LE_OP (258) 106
NE_OP (259) 110
GE_OP (260) 108
EQ_OP (261) 107
AND_OP (262) 99
OR_OP (263) 97
READ (264) 62
BOOLEAN (265)
WHILE (266) 68 70
DO (267) 70
IF (268) 63 64
ELSE (269) 64
TRUE (270) 144
FALSE (271) 145
FOR (272) 72
INT (273) 132
PRINT (274) 61
BOOL (275) 135
VOID (276) 16 18 21 22
FLOAT (277) 136
DOUBLE (278) 133
STRING (279) 134
CONTINUE (280) 91
BREAK (281) 92
RETURN (282) 93
CONST (283) 40
L_PAREN (284) 12 14 16 18 19 20 21 22 63 64 68 70 72 89 90 123 124
    125 126 127 128
R_PAREN (285) 12 14 16 18 19 20 21 22 63 64 68 70 72 89 90 123 124
    125 126 127 128
COMMA (286) 23 24 28 29 30 31 37 41 73 74 78 79 83 84 130
SEMICOLON (287) 19 20 21 22 27 40 59 61 62 70 72 89 90 91 92 93
ML_BRACE (288) 44 45 96
MR_BRACE (289) 44 45 96
L_BRACE (290) 36 47
R_BRACE (291) 36 47
ADD_OP (292) 114
SUB_OP (293) 115 122 124 126 128 138 140 142
MUL_OP (294) 118
DIV_OP (295) 119
MOD_OP (296) 120
ASSIGN_OP (297) 29 30 32 34 41 42 59 88
LT_OP (298) 105
GT_OP (299) 109
NOT_OP (300) 101
ID (301) 12 14 16 18 19 20 21 22 23 26 28 29 34 35 41 42 43 89 90 94
    125 126 127 128
INT_CONST (302) 44 45 137 138
FLOAT_CONST (303) 139 140
SCIENTIFIC (304) 141 142
STR_CONST (305) 143


Nonterminals, with rules where they appear

$accept (51)
    on left: 0
program (52)
    on left: 1, on right: 0
decl_list (53)
    on left: 2 3 4 5, on right: 1 2 3 4
decl_and_def_list (54)
    on left: 6 7 8 9 10, on right: 1 6 7 8 9
funct_def (55)
    on left: 12 14 16 18, on right: 1 9
$@1 (56)
    on left: 11, on right: 12
$@2 (57)
    on left: 13, on right: 14
$@3 (58)
    on left: 15, on right: 16
$@4 (59)
    on left: 17, on right: 18
funct_decl (60)
    on left: 19 20 21 22, on right: 4 8
parameter_list (61)
    on left: 23 24 25 26, on right: 14 18 20 22 23 24
var_decl (62)
    on left: 27, on right: 2 6 49
identifier_list (63)
    on left: 28 29 30 31 32 33 34 35, on right: 27 28 29 30 31
initial_array (64)
    on left: 36, on right: 30 32
literal_list (65)
    on left: 37 38 39, on right: 36 37
const_decl (66)
    on left: 40, on right: 3 7 50
const_list (67)
    on left: 41 42, on right: 40 41
array_decl (68)
    on left: 43, on right: 24 25 30 31 32 33
dim (69)
    on left: 44 45, on right: 43 44
compound_statement (70)
    on left: 47, on right: 12 14 16 18 52 63 64 68 70 72
$@5 (71)
    on left: 46, on right: 47
var_const_stmt_list (72)
    on left: 48 49 50 51, on right: 47 48 49 50
statement (73)
    on left: 52 53 54 55 56 57 58, on right: 48
simple_statement (74)
    on left: 59 61 62, on right: 53
$@6 (75)
    on left: 60, on right: 61
conditional_statement (76)
    on left: 63 64, on right: 54
conditional_if (77)
    on left: 65, on right: 63 64
while_statement (78)
    on left: 68 70, on right: 55
$@7 (79)
    on left: 66, on right: 68
$@8 (80)
    on left: 67, on right: 68
$@9 (81)
    on left: 69, on right: 70
for_statement (82)
    on left: 72, on right: 56
$@10 (83)
    on left: 71, on right: 72
initial_expression (84)
    on left: 73 74 75 76 77, on right: 72 73 74
control_expression (85)
    on left: 78 79 80 81 82, on right: 72 78 79
increment_expression (86)
    on left: 83 84 85 86 87, on right: 72 83 84
statement_for (87)
    on left: 88, on right: 73 76 78 81 83 86
function_invoke_statement (88)
    on left: 89 90, on right: 57
jump_statement (89)
    on left: 91 92 93, on right: 58
variable_reference (90)
    on left: 94 95, on right: 59 62 88 95 121 122
dimension (91)
    on left: 96, on right: 95
logical_expression (92)
    on left: 97 98, on right: 29 34 37 38 59 61 65 68 70 74 75 79 80
    84 85 88 93 97 123 124 130 131
logical_term (93)
    on left: 99 100, on right: 97 98 99
logical_factor (94)
    on left: 101 102, on right: 99 100 101
relation_expression (95)
    on left: 103 104, on right: 102 112
relation_operator (96)
    on left: 105 106 107 108 109 110, on right: 103
arithmetic_expression (97)
    on left: 111 112 113, on right: 96 103 104 111
add_op (98)
    on left: 114 115, on right: 111
term (99)
    on left: 116 117, on right: 111 113 116
mul_op (100)
    on left: 118 119 120, on right: 116
factor (101)
    on left: 121 122 123 124 125 126 127 128 129, on right: 116 117
logical_expression_list (102)
    on left: 130 131, on right: 89 125 126 130
scalar_type (103)
    on left: 132 133 134 135 136, on right: 12 14 19 20 23 24 25 26
    27 40
literal_const (104)
    on left: 137 138 139 140 141 142 143 144 145, on right: 41 42 129


State 0

    0 $accept: . program $end

    $default  reduce using rule 5 (decl_list)

    program    go to state 1
    decl_list  go to state 2


State 1

    0 $accept: program . $end

    $end  shift, and go to state 3


State 2

    1 program: decl_list . funct_def decl_and_def_list
    2 decl_list: decl_list . var_decl
    3          | decl_list . const_decl
    4          | decl_list . funct_decl

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    VOID    shift, and go to state 6
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9
    CONST   shift, and go to state 10

    funct_def    go to state 11
    funct_decl   go to state 12
    var_decl     go to state 13
    const_decl   go to state 14
    scalar_type  go to state 15


State 3

    0 $accept: program $end .

    $default  accept


State 4

  132 scalar_type: INT .

    $default  reduce using rule 132 (scalar_type)


State 5

  135 scalar_type: BOOL .

    $default  reduce using rule 135 (scalar_type)


State 6

   16 funct_def: VOID . ID L_PAREN R_PAREN $@3 compound_statement
   18          | VOID . ID L_PAREN parameter_list R_PAREN $@4 compound_statement
   21 funct_decl: VOID . ID L_PAREN R_PAREN SEMICOLON
   22           | VOID . ID L_PAREN parameter_list R_PAREN SEMICOLON

    ID  shift, and go to state 16


State 7

  136 scalar_type: FLOAT .

    $default  reduce using rule 136 (scalar_type)


State 8

  133 scalar_type: DOUBLE .

    $default  reduce using rule 133 (scalar_type)


State 9

  134 scalar_type: STRING .

    $default  reduce using rule 134 (scalar_type)


State 10

   40 const_decl: CONST . scalar_type const_list SEMICOLON

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9

    scalar_type  go to state 17


State 11

    1 program: decl_list funct_def . decl_and_def_list

    $default  reduce using rule 10 (decl_and_def_list)

    decl_and_def_list  go to state 18


State 12

    4 decl_list: decl_list funct_decl .

    $default  reduce using rule 4 (decl_list)


State 13

    2 decl_list: decl_list var_decl .

    $default  reduce using rule 2 (decl_list)


State 14

    3 decl_list: decl_list const_decl .

    $default  reduce using rule 3 (decl_list)


State 15

   12 funct_def: scalar_type . ID L_PAREN R_PAREN $@1 compound_statement
   14          | scalar_type . ID L_PAREN parameter_list R_PAREN $@2 compound_statement
   19 funct_decl: scalar_type . ID L_PAREN R_PAREN SEMICOLON
   20           | scalar_type . ID L_PAREN parameter_list R_PAREN SEMICOLON
   27 var_decl: scalar_type . identifier_list SEMICOLON

    ID  shift, and go to state 19

    identifier_list  go to state 20
    array_decl       go to state 21


State 16

   16 funct_def: VOID ID . L_PAREN R_PAREN $@3 compound_statement
   18          | VOID ID . L_PAREN parameter_list R_PAREN $@4 compound_statement
   21 funct_decl: VOID ID . L_PAREN R_PAREN SEMICOLON
   22           | VOID ID . L_PAREN parameter_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 22


State 17

   40 const_decl: CONST scalar_type . const_list SEMICOLON

    ID  shift, and go to state 23

    const_list  go to state 24


State 18

    1 program: decl_list funct_def decl_and_def_list .
    6 decl_and_def_list: decl_and_def_list . var_decl
    7                  | decl_and_def_list . const_decl
    8                  | decl_and_def_list . funct_decl
    9                  | decl_and_def_list . funct_def

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    VOID    shift, and go to state 6
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9
    CONST   shift, and go to state 10

    $default  reduce using rule 1 (program)

    funct_def    go to state 25
    funct_decl   go to state 26
    var_decl     go to state 27
    const_decl   go to state 28
    scalar_type  go to state 15


State 19

   12 funct_def: scalar_type ID . L_PAREN R_PAREN $@1 compound_statement
   14          | scalar_type ID . L_PAREN parameter_list R_PAREN $@2 compound_statement
   19 funct_decl: scalar_type ID . L_PAREN R_PAREN SEMICOLON
   20           | scalar_type ID . L_PAREN parameter_list R_PAREN SEMICOLON
   34 identifier_list: ID . ASSIGN_OP logical_expression
   35                | ID .
   43 array_decl: ID . dim

    L_PAREN    shift, and go to state 29
    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 31

    $default  reduce using rule 35 (identifier_list)

    dim  go to state 32


State 20

   27 var_decl: scalar_type identifier_list . SEMICOLON
   28 identifier_list: identifier_list . COMMA ID
   29                | identifier_list . COMMA ID ASSIGN_OP logical_expression
   30                | identifier_list . COMMA array_decl ASSIGN_OP initial_array
   31                | identifier_list . COMMA array_decl

    COMMA      shift, and go to state 33
    SEMICOLON  shift, and go to state 34


State 21

   32 identifier_list: array_decl . ASSIGN_OP initial_array
   33                | array_decl .

    ASSIGN_OP  shift, and go to state 35

    $default  reduce using rule 33 (identifier_list)


State 22

   16 funct_def: VOID ID L_PAREN . R_PAREN $@3 compound_statement
   18          | VOID ID L_PAREN . parameter_list R_PAREN $@4 compound_statement
   21 funct_decl: VOID ID L_PAREN . R_PAREN SEMICOLON
   22           | VOID ID L_PAREN . parameter_list R_PAREN SEMICOLON

    INT      shift, and go to state 4
    BOOL     shift, and go to state 5
    FLOAT    shift, and go to state 7
    DOUBLE   shift, and go to state 8
    STRING   shift, and go to state 9
    R_PAREN  shift, and go to state 36

    parameter_list  go to state 37
    scalar_type     go to state 38


State 23

   42 const_list: ID . ASSIGN_OP literal_const

    ASSIGN_OP  shift, and go to state 39


State 24

   40 const_decl: CONST scalar_type const_list . SEMICOLON
   41 const_list: const_list . COMMA ID ASSIGN_OP literal_const

    COMMA      shift, and go to state 40
    SEMICOLON  shift, and go to state 41


State 25

    9 decl_and_def_list: decl_and_def_list funct_def .

    $default  reduce using rule 9 (decl_and_def_list)


State 26

    8 decl_and_def_list: decl_and_def_list funct_decl .

    $default  reduce using rule 8 (decl_and_def_list)


State 27

    6 decl_and_def_list: decl_and_def_list var_decl .

    $default  reduce using rule 6 (decl_and_def_list)


State 28

    7 decl_and_def_list: decl_and_def_list const_decl .

    $default  reduce using rule 7 (decl_and_def_list)


State 29

   12 funct_def: scalar_type ID L_PAREN . R_PAREN $@1 compound_statement
   14          | scalar_type ID L_PAREN . parameter_list R_PAREN $@2 compound_statement
   19 funct_decl: scalar_type ID L_PAREN . R_PAREN SEMICOLON
   20           | scalar_type ID L_PAREN . parameter_list R_PAREN SEMICOLON

    INT      shift, and go to state 4
    BOOL     shift, and go to state 5
    FLOAT    shift, and go to state 7
    DOUBLE   shift, and go to state 8
    STRING   shift, and go to state 9
    R_PAREN  shift, and go to state 42

    parameter_list  go to state 43
    scalar_type     go to state 38


State 30

   45 dim: ML_BRACE . INT_CONST MR_BRACE

    INT_CONST  shift, and go to state 44


State 31

   34 identifier_list: ID ASSIGN_OP . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 56
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 32

   43 array_decl: ID dim .
   44 dim: dim . ML_BRACE INT_CONST MR_BRACE

    ML_BRACE  shift, and go to state 64

    $default  reduce using rule 43 (array_decl)


State 33

   28 identifier_list: identifier_list COMMA . ID
   29                | identifier_list COMMA . ID ASSIGN_OP logical_expression
   30                | identifier_list COMMA . array_decl ASSIGN_OP initial_array
   31                | identifier_list COMMA . array_decl

    ID  shift, and go to state 65

    array_decl  go to state 66


State 34

   27 var_decl: scalar_type identifier_list SEMICOLON .

    $default  reduce using rule 27 (var_decl)


State 35

   32 identifier_list: array_decl ASSIGN_OP . initial_array

    L_BRACE  shift, and go to state 67

    initial_array  go to state 68


State 36

   16 funct_def: VOID ID L_PAREN R_PAREN . $@3 compound_statement
   21 funct_decl: VOID ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 69

    $default  reduce using rule 15 ($@3)

    $@3  go to state 70


State 37

   18 funct_def: VOID ID L_PAREN parameter_list . R_PAREN $@4 compound_statement
   22 funct_decl: VOID ID L_PAREN parameter_list . R_PAREN SEMICOLON
   23 parameter_list: parameter_list . COMMA scalar_type ID
   24               | parameter_list . COMMA scalar_type array_decl

    R_PAREN  shift, and go to state 71
    COMMA    shift, and go to state 72


State 38

   25 parameter_list: scalar_type . array_decl
   26               | scalar_type . ID

    ID  shift, and go to state 73

    array_decl  go to state 74


State 39

   42 const_list: ID ASSIGN_OP . literal_const

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    SUB_OP       shift, and go to state 75
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    literal_const  go to state 76


State 40

   41 const_list: const_list COMMA . ID ASSIGN_OP literal_const

    ID  shift, and go to state 77


State 41

   40 const_decl: CONST scalar_type const_list SEMICOLON .

    $default  reduce using rule 40 (const_decl)


State 42

   12 funct_def: scalar_type ID L_PAREN R_PAREN . $@1 compound_statement
   19 funct_decl: scalar_type ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 78

    $default  reduce using rule 11 ($@1)

    $@1  go to state 79


State 43

   14 funct_def: scalar_type ID L_PAREN parameter_list . R_PAREN $@2 compound_statement
   20 funct_decl: scalar_type ID L_PAREN parameter_list . R_PAREN SEMICOLON
   23 parameter_list: parameter_list . COMMA scalar_type ID
   24               | parameter_list . COMMA scalar_type array_decl

    R_PAREN  shift, and go to state 80
    COMMA    shift, and go to state 72


State 44

   45 dim: ML_BRACE INT_CONST . MR_BRACE

    MR_BRACE  shift, and go to state 81


State 45

  144 literal_const: TRUE .

    $default  reduce using rule 144 (literal_const)


State 46

  145 literal_const: FALSE .

    $default  reduce using rule 145 (literal_const)


State 47

  123 factor: L_PAREN . logical_expression R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 82
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 48

  122 factor: SUB_OP . variable_reference
  124       | SUB_OP . L_PAREN logical_expression R_PAREN
  126       | SUB_OP . ID L_PAREN logical_expression_list R_PAREN
  128       | SUB_OP . ID L_PAREN R_PAREN
  138 literal_const: SUB_OP . INT_CONST
  140              | SUB_OP . FLOAT_CONST
  142              | SUB_OP . SCIENTIFIC

    L_PAREN      shift, and go to state 83
    ID           shift, and go to state 84
    INT_CONST    shift, and go to state 85
    FLOAT_CONST  shift, and go to state 86
    SCIENTIFIC   shift, and go to state 87

    variable_reference  go to state 88


State 49

  101 logical_factor: NOT_OP . logical_factor

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_factor         go to state 89
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 50

   94 variable_reference: ID .
  125 factor: ID . L_PAREN logical_expression_list R_PAREN
  127       | ID . L_PAREN R_PAREN

    L_PAREN  shift, and go to state 90

    $default  reduce using rule 94 (variable_reference)


State 51

  137 literal_const: INT_CONST .

    $default  reduce using rule 137 (literal_const)


State 52

  139 literal_const: FLOAT_CONST .

    $default  reduce using rule 139 (literal_const)


State 53

  141 literal_const: SCIENTIFIC .

    $default  reduce using rule 141 (literal_const)


State 54

  143 literal_const: STR_CONST .

    $default  reduce using rule 143 (literal_const)


State 55

   95 variable_reference: variable_reference . dimension
  121 factor: variable_reference .

    ML_BRACE  shift, and go to state 91

    $default  reduce using rule 121 (factor)

    dimension  go to state 92


State 56

   34 identifier_list: ID ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 34 (identifier_list)


State 57

   98 logical_expression: logical_term .
   99 logical_term: logical_term . AND_OP logical_factor

    AND_OP  shift, and go to state 94

    $default  reduce using rule 98 (logical_expression)


State 58

  100 logical_term: logical_factor .

    $default  reduce using rule 100 (logical_term)


State 59

  102 logical_factor: relation_expression .
  112 arithmetic_expression: relation_expression .

    AND_OP     reduce using rule 102 (logical_factor)
    AND_OP     [reduce using rule 112 (arithmetic_expression)]
    OR_OP      reduce using rule 102 (logical_factor)
    OR_OP      [reduce using rule 112 (arithmetic_expression)]
    R_PAREN    reduce using rule 102 (logical_factor)
    R_PAREN    [reduce using rule 112 (arithmetic_expression)]
    COMMA      reduce using rule 102 (logical_factor)
    COMMA      [reduce using rule 112 (arithmetic_expression)]
    SEMICOLON  reduce using rule 102 (logical_factor)
    SEMICOLON  [reduce using rule 112 (arithmetic_expression)]
    R_BRACE    reduce using rule 102 (logical_factor)
    R_BRACE    [reduce using rule 112 (arithmetic_expression)]
    $default   reduce using rule 112 (arithmetic_expression)


State 60

  103 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  104                    | arithmetic_expression .
  111 arithmetic_expression: arithmetic_expression . add_op term

    LE_OP   shift, and go to state 95
    NE_OP   shift, and go to state 96
    GE_OP   shift, and go to state 97
    EQ_OP   shift, and go to state 98
    ADD_OP  shift, and go to state 99
    SUB_OP  shift, and go to state 100
    LT_OP   shift, and go to state 101
    GT_OP   shift, and go to state 102

    LE_OP     [reduce using rule 104 (relation_expression)]
    NE_OP     [reduce using rule 104 (relation_expression)]
    GE_OP     [reduce using rule 104 (relation_expression)]
    EQ_OP     [reduce using rule 104 (relation_expression)]
    ADD_OP    [reduce using rule 104 (relation_expression)]
    SUB_OP    [reduce using rule 104 (relation_expression)]
    LT_OP     [reduce using rule 104 (relation_expression)]
    GT_OP     [reduce using rule 104 (relation_expression)]
    $default  reduce using rule 104 (relation_expression)

    relation_operator  go to state 103
    add_op             go to state 104


State 61

  113 arithmetic_expression: term .
  116 term: term . mul_op factor

    MUL_OP  shift, and go to state 105
    DIV_OP  shift, and go to state 106
    MOD_OP  shift, and go to state 107

    $default  reduce using rule 113 (arithmetic_expression)

    mul_op  go to state 108


State 62

  117 term: factor .

    $default  reduce using rule 117 (term)


State 63

  129 factor: literal_const .

    $default  reduce using rule 129 (factor)


State 64

   44 dim: dim ML_BRACE . INT_CONST MR_BRACE

    INT_CONST  shift, and go to state 109


State 65

   28 identifier_list: identifier_list COMMA ID .
   29                | identifier_list COMMA ID . ASSIGN_OP logical_expression
   43 array_decl: ID . dim

    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 110

    $default  reduce using rule 28 (identifier_list)

    dim  go to state 32


State 66

   30 identifier_list: identifier_list COMMA array_decl . ASSIGN_OP initial_array
   31                | identifier_list COMMA array_decl .

    ASSIGN_OP  shift, and go to state 111

    $default  reduce using rule 31 (identifier_list)


State 67

   36 initial_array: L_BRACE . literal_list R_BRACE

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 39 (literal_list)

    literal_list           go to state 112
    variable_reference     go to state 55
    logical_expression     go to state 113
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 68

   32 identifier_list: array_decl ASSIGN_OP initial_array .

    $default  reduce using rule 32 (identifier_list)


State 69

   21 funct_decl: VOID ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 21 (funct_decl)


State 70

   16 funct_def: VOID ID L_PAREN R_PAREN $@3 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 114
    $@5                 go to state 115


State 71

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN . $@4 compound_statement
   22 funct_decl: VOID ID L_PAREN parameter_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 116

    $default  reduce using rule 17 ($@4)

    $@4  go to state 117


State 72

   23 parameter_list: parameter_list COMMA . scalar_type ID
   24               | parameter_list COMMA . scalar_type array_decl

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9

    scalar_type  go to state 118


State 73

   26 parameter_list: scalar_type ID .
   43 array_decl: ID . dim

    ML_BRACE  shift, and go to state 30

    $default  reduce using rule 26 (parameter_list)

    dim  go to state 32


State 74

   25 parameter_list: scalar_type array_decl .

    $default  reduce using rule 25 (parameter_list)


State 75

  138 literal_const: SUB_OP . INT_CONST
  140              | SUB_OP . FLOAT_CONST
  142              | SUB_OP . SCIENTIFIC

    INT_CONST    shift, and go to state 85
    FLOAT_CONST  shift, and go to state 86
    SCIENTIFIC   shift, and go to state 87


State 76

   42 const_list: ID ASSIGN_OP literal_const .

    $default  reduce using rule 42 (const_list)


State 77

   41 const_list: const_list COMMA ID . ASSIGN_OP literal_const

    ASSIGN_OP  shift, and go to state 119


State 78

   19 funct_decl: scalar_type ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 19 (funct_decl)


State 79

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 120
    $@5                 go to state 115


State 80

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN . $@2 compound_statement
   20 funct_decl: scalar_type ID L_PAREN parameter_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 121

    $default  reduce using rule 13 ($@2)

    $@2  go to state 122


State 81

   45 dim: ML_BRACE INT_CONST MR_BRACE .

    $default  reduce using rule 45 (dim)


State 82

   97 logical_expression: logical_expression . OR_OP logical_term
  123 factor: L_PAREN logical_expression . R_PAREN

    OR_OP    shift, and go to state 93
    R_PAREN  shift, and go to state 123


State 83

  124 factor: SUB_OP L_PAREN . logical_expression R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 124
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 84

   94 variable_reference: ID .
  126 factor: SUB_OP ID . L_PAREN logical_expression_list R_PAREN
  128       | SUB_OP ID . L_PAREN R_PAREN

    L_PAREN  shift, and go to state 125

    $default  reduce using rule 94 (variable_reference)


State 85

  138 literal_const: SUB_OP INT_CONST .

    $default  reduce using rule 138 (literal_const)


State 86

  140 literal_const: SUB_OP FLOAT_CONST .

    $default  reduce using rule 140 (literal_const)


State 87

  142 literal_const: SUB_OP SCIENTIFIC .

    $default  reduce using rule 142 (literal_const)


State 88

   95 variable_reference: variable_reference . dimension
  122 factor: SUB_OP variable_reference .

    ML_BRACE  shift, and go to state 91

    $default  reduce using rule 122 (factor)

    dimension  go to state 92


State 89

  101 logical_factor: NOT_OP logical_factor .

    $default  reduce using rule 101 (logical_factor)


State 90

  125 factor: ID L_PAREN . logical_expression_list R_PAREN
  127       | ID L_PAREN . R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    R_PAREN      shift, and go to state 126
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 127
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 128
    literal_const            go to state 63


State 91

   96 dimension: ML_BRACE . arithmetic_expression MR_BRACE

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    relation_expression    go to state 129
    arithmetic_expression  go to state 130
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 92

   95 variable_reference: variable_reference dimension .

    $default  reduce using rule 95 (variable_reference)


State 93

   97 logical_expression: logical_expression OR_OP . logical_term

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_term           go to state 131
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 94

   99 logical_term: logical_term AND_OP . logical_factor

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_factor         go to state 132
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 95

  106 relation_operator: LE_OP .

    $default  reduce using rule 106 (relation_operator)


State 96

  110 relation_operator: NE_OP .

    $default  reduce using rule 110 (relation_operator)


State 97

  108 relation_operator: GE_OP .

    $default  reduce using rule 108 (relation_operator)


State 98

  107 relation_operator: EQ_OP .

    $default  reduce using rule 107 (relation_operator)


State 99

  114 add_op: ADD_OP .

    $default  reduce using rule 114 (add_op)


State 100

  115 add_op: SUB_OP .

    $default  reduce using rule 115 (add_op)


State 101

  105 relation_operator: LT_OP .

    $default  reduce using rule 105 (relation_operator)


State 102

  109 relation_operator: GT_OP .

    $default  reduce using rule 109 (relation_operator)


State 103

  103 relation_expression: arithmetic_expression relation_operator . arithmetic_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    relation_expression    go to state 129
    arithmetic_expression  go to state 133
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 104

  111 arithmetic_expression: arithmetic_expression add_op . term

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference  go to state 55
    term                go to state 134
    factor              go to state 62
    literal_const       go to state 63


State 105

  118 mul_op: MUL_OP .

    $default  reduce using rule 118 (mul_op)


State 106

  119 mul_op: DIV_OP .

    $default  reduce using rule 119 (mul_op)


State 107

  120 mul_op: MOD_OP .

    $default  reduce using rule 120 (mul_op)


State 108

  116 term: term mul_op . factor

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference  go to state 55
    factor              go to state 135
    literal_const       go to state 63


State 109

   44 dim: dim ML_BRACE INT_CONST . MR_BRACE

    MR_BRACE  shift, and go to state 136


State 110

   29 identifier_list: identifier_list COMMA ID ASSIGN_OP . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 137
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 111

   30 identifier_list: identifier_list COMMA array_decl ASSIGN_OP . initial_array

    L_BRACE  shift, and go to state 67

    initial_array  go to state 138


State 112

   36 initial_array: L_BRACE literal_list . R_BRACE
   37 literal_list: literal_list . COMMA logical_expression

    COMMA    shift, and go to state 139
    R_BRACE  shift, and go to state 140


State 113

   38 literal_list: logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 38 (literal_list)


State 114

   16 funct_def: VOID ID L_PAREN R_PAREN $@3 compound_statement .

    $default  reduce using rule 16 (funct_def)


State 115

   47 compound_statement: $@5 . L_BRACE var_const_stmt_list R_BRACE

    L_BRACE  shift, and go to state 141


State 116

   22 funct_decl: VOID ID L_PAREN parameter_list R_PAREN SEMICOLON .

    $default  reduce using rule 22 (funct_decl)


State 117

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@4 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 142
    $@5                 go to state 115


State 118

   23 parameter_list: parameter_list COMMA scalar_type . ID
   24               | parameter_list COMMA scalar_type . array_decl

    ID  shift, and go to state 143

    array_decl  go to state 144


State 119

   41 const_list: const_list COMMA ID ASSIGN_OP . literal_const

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    SUB_OP       shift, and go to state 75
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    literal_const  go to state 145


State 120

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 compound_statement .

    $default  reduce using rule 12 (funct_def)


State 121

   20 funct_decl: scalar_type ID L_PAREN parameter_list R_PAREN SEMICOLON .

    $default  reduce using rule 20 (funct_decl)


State 122

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 146
    $@5                 go to state 115


State 123

  123 factor: L_PAREN logical_expression R_PAREN .

    $default  reduce using rule 123 (factor)


State 124

   97 logical_expression: logical_expression . OR_OP logical_term
  124 factor: SUB_OP L_PAREN logical_expression . R_PAREN

    OR_OP    shift, and go to state 93
    R_PAREN  shift, and go to state 147


State 125

  126 factor: SUB_OP ID L_PAREN . logical_expression_list R_PAREN
  128       | SUB_OP ID L_PAREN . R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    R_PAREN      shift, and go to state 148
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 127
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 149
    literal_const            go to state 63


State 126

  127 factor: ID L_PAREN R_PAREN .

    $default  reduce using rule 127 (factor)


State 127

   97 logical_expression: logical_expression . OR_OP logical_term
  131 logical_expression_list: logical_expression .

    OR_OP  shift, and go to state 93

    $default  reduce using rule 131 (logical_expression_list)


State 128

  125 factor: ID L_PAREN logical_expression_list . R_PAREN
  130 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 150
    COMMA    shift, and go to state 151


State 129

  112 arithmetic_expression: relation_expression .

    $default  reduce using rule 112 (arithmetic_expression)


State 130

   96 dimension: ML_BRACE arithmetic_expression . MR_BRACE
  103 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  104                    | arithmetic_expression .
  111 arithmetic_expression: arithmetic_expression . add_op term

    LE_OP     shift, and go to state 95
    NE_OP     shift, and go to state 96
    GE_OP     shift, and go to state 97
    EQ_OP     shift, and go to state 98
    MR_BRACE  shift, and go to state 152
    ADD_OP    shift, and go to state 99
    SUB_OP    shift, and go to state 100
    LT_OP     shift, and go to state 101
    GT_OP     shift, and go to state 102

    LE_OP     [reduce using rule 104 (relation_expression)]
    NE_OP     [reduce using rule 104 (relation_expression)]
    GE_OP     [reduce using rule 104 (relation_expression)]
    EQ_OP     [reduce using rule 104 (relation_expression)]
    MR_BRACE  [reduce using rule 104 (relation_expression)]
    ADD_OP    [reduce using rule 104 (relation_expression)]
    SUB_OP    [reduce using rule 104 (relation_expression)]
    LT_OP     [reduce using rule 104 (relation_expression)]
    GT_OP     [reduce using rule 104 (relation_expression)]

    relation_operator  go to state 103
    add_op             go to state 104


State 131

   97 logical_expression: logical_expression OR_OP logical_term .
   99 logical_term: logical_term . AND_OP logical_factor

    AND_OP  shift, and go to state 94

    $default  reduce using rule 97 (logical_expression)


State 132

   99 logical_term: logical_term AND_OP logical_factor .

    $default  reduce using rule 99 (logical_term)


State 133

  103 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  103                    | arithmetic_expression relation_operator arithmetic_expression .
  104                    | arithmetic_expression .
  111 arithmetic_expression: arithmetic_expression . add_op term

    LE_OP   shift, and go to state 95
    NE_OP   shift, and go to state 96
    GE_OP   shift, and go to state 97
    EQ_OP   shift, and go to state 98
    ADD_OP  shift, and go to state 99
    SUB_OP  shift, and go to state 100
    LT_OP   shift, and go to state 101
    GT_OP   shift, and go to state 102

    LE_OP      [reduce using rule 103 (relation_expression)]
    LE_OP      [reduce using rule 104 (relation_expression)]
    NE_OP      [reduce using rule 103 (relation_expression)]
    NE_OP      [reduce using rule 104 (relation_expression)]
    GE_OP      [reduce using rule 103 (relation_expression)]
    GE_OP      [reduce using rule 104 (relation_expression)]
    EQ_OP      [reduce using rule 103 (relation_expression)]
    EQ_OP      [reduce using rule 104 (relation_expression)]
    AND_OP     reduce using rule 103 (relation_expression)
    AND_OP     [reduce using rule 104 (relation_expression)]
    OR_OP      reduce using rule 103 (relation_expression)
    OR_OP      [reduce using rule 104 (relation_expression)]
    R_PAREN    reduce using rule 103 (relation_expression)
    R_PAREN    [reduce using rule 104 (relation_expression)]
    COMMA      reduce using rule 103 (relation_expression)
    COMMA      [reduce using rule 104 (relation_expression)]
    SEMICOLON  reduce using rule 103 (relation_expression)
    SEMICOLON  [reduce using rule 104 (relation_expression)]
    MR_BRACE   reduce using rule 103 (relation_expression)
    MR_BRACE   [reduce using rule 104 (relation_expression)]
    R_BRACE    reduce using rule 103 (relation_expression)
    R_BRACE    [reduce using rule 104 (relation_expression)]
    ADD_OP     [reduce using rule 103 (relation_expression)]
    ADD_OP     [reduce using rule 104 (relation_expression)]
    SUB_OP     [reduce using rule 103 (relation_expression)]
    SUB_OP     [reduce using rule 104 (relation_expression)]
    LT_OP      [reduce using rule 103 (relation_expression)]
    LT_OP      [reduce using rule 104 (relation_expression)]
    GT_OP      [reduce using rule 103 (relation_expression)]
    GT_OP      [reduce using rule 104 (relation_expression)]
    $default   reduce using rule 103 (relation_expression)

    relation_operator  go to state 103
    add_op             go to state 104


State 134

  111 arithmetic_expression: arithmetic_expression add_op term .
  116 term: term . mul_op factor

    MUL_OP  shift, and go to state 105
    DIV_OP  shift, and go to state 106
    MOD_OP  shift, and go to state 107

    $default  reduce using rule 111 (arithmetic_expression)

    mul_op  go to state 108


State 135

  116 term: term mul_op factor .

    $default  reduce using rule 116 (term)


State 136

   44 dim: dim ML_BRACE INT_CONST MR_BRACE .

    $default  reduce using rule 44 (dim)


State 137

   29 identifier_list: identifier_list COMMA ID ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 29 (identifier_list)


State 138

   30 identifier_list: identifier_list COMMA array_decl ASSIGN_OP initial_array .

    $default  reduce using rule 30 (identifier_list)


State 139

   37 literal_list: literal_list COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 153
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 140

   36 initial_array: L_BRACE literal_list R_BRACE .

    $default  reduce using rule 36 (initial_array)


State 141

   47 compound_statement: $@5 L_BRACE . var_const_stmt_list R_BRACE

    $default  reduce using rule 51 (var_const_stmt_list)

    var_const_stmt_list  go to state 154


State 142

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@4 compound_statement .

    $default  reduce using rule 18 (funct_def)


State 143

   23 parameter_list: parameter_list COMMA scalar_type ID .
   43 array_decl: ID . dim

    ML_BRACE  shift, and go to state 30

    $default  reduce using rule 23 (parameter_list)

    dim  go to state 32


State 144

   24 parameter_list: parameter_list COMMA scalar_type array_decl .

    $default  reduce using rule 24 (parameter_list)


State 145

   41 const_list: const_list COMMA ID ASSIGN_OP literal_const .

    $default  reduce using rule 41 (const_list)


State 146

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 compound_statement .

    $default  reduce using rule 14 (funct_def)


State 147

  124 factor: SUB_OP L_PAREN logical_expression R_PAREN .

    $default  reduce using rule 124 (factor)


State 148

  128 factor: SUB_OP ID L_PAREN R_PAREN .

    $default  reduce using rule 128 (factor)


State 149

  126 factor: SUB_OP ID L_PAREN logical_expression_list . R_PAREN
  130 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 155
    COMMA    shift, and go to state 151


State 150

  125 factor: ID L_PAREN logical_expression_list R_PAREN .

    $default  reduce using rule 125 (factor)


State 151

  130 logical_expression_list: logical_expression_list COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 156
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 152

   96 dimension: ML_BRACE arithmetic_expression MR_BRACE .

    $default  reduce using rule 96 (dimension)


State 153

   37 literal_list: literal_list COMMA logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 37 (literal_list)


State 154

   47 compound_statement: $@5 L_BRACE var_const_stmt_list . R_BRACE
   48 var_const_stmt_list: var_const_stmt_list . statement
   49                    | var_const_stmt_list . var_decl
   50                    | var_const_stmt_list . const_decl

    READ      shift, and go to state 157
    WHILE     shift, and go to state 158
    IF        shift, and go to state 159
    FOR       shift, and go to state 160
    INT       shift, and go to state 4
    PRINT     shift, and go to state 161
    BOOL      shift, and go to state 5
    FLOAT     shift, and go to state 7
    DOUBLE    shift, and go to state 8
    STRING    shift, and go to state 9
    CONTINUE  shift, and go to state 162
    BREAK     shift, and go to state 163
    RETURN    shift, and go to state 164
    CONST     shift, and go to state 10
    R_BRACE   shift, and go to state 165
    ID        shift, and go to state 166

    DO        reduce using rule 69 ($@9)
    $default  reduce using rule 46 ($@5)

    var_decl                   go to state 167
    const_decl                 go to state 168
    compound_statement         go to state 169
    $@5                        go to state 115
    statement                  go to state 170
    simple_statement           go to state 171
    conditional_statement      go to state 172
    while_statement            go to state 173
    $@9                        go to state 174
    for_statement              go to state 175
    function_invoke_statement  go to state 176
    jump_statement             go to state 177
    variable_reference         go to state 178
    scalar_type                go to state 179


State 155

  126 factor: SUB_OP ID L_PAREN logical_expression_list R_PAREN .

    $default  reduce using rule 126 (factor)


State 156

   97 logical_expression: logical_expression . OR_OP logical_term
  130 logical_expression_list: logical_expression_list COMMA logical_expression .

    OR_OP  shift, and go to state 93

    $default  reduce using rule 130 (logical_expression_list)


State 157

   62 simple_statement: READ . variable_reference SEMICOLON

    ID  shift, and go to state 180

    variable_reference  go to state 181


State 158

   68 while_statement: WHILE . L_PAREN logical_expression $@7 R_PAREN $@8 compound_statement

    L_PAREN  shift, and go to state 182


State 159

   63 conditional_statement: IF . L_PAREN conditional_if R_PAREN compound_statement
   64                      | IF . L_PAREN conditional_if R_PAREN compound_statement ELSE compound_statement

    L_PAREN  shift, and go to state 183


State 160

   72 for_statement: FOR . L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@10 compound_statement

    L_PAREN  shift, and go to state 184


State 161

   61 simple_statement: PRINT . $@6 logical_expression SEMICOLON

    $default  reduce using rule 60 ($@6)

    $@6  go to state 185


State 162

   91 jump_statement: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 186


State 163

   92 jump_statement: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 187


State 164

   93 jump_statement: RETURN . logical_expression SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 188
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 165

   47 compound_statement: $@5 L_BRACE var_const_stmt_list R_BRACE .

    $default  reduce using rule 47 (compound_statement)


State 166

   89 function_invoke_statement: ID . L_PAREN logical_expression_list R_PAREN SEMICOLON
   90                          | ID . L_PAREN R_PAREN SEMICOLON
   94 variable_reference: ID .

    L_PAREN  shift, and go to state 189

    $default  reduce using rule 94 (variable_reference)


State 167

   49 var_const_stmt_list: var_const_stmt_list var_decl .

    $default  reduce using rule 49 (var_const_stmt_list)


State 168

   50 var_const_stmt_list: var_const_stmt_list const_decl .

    $default  reduce using rule 50 (var_const_stmt_list)


State 169

   52 statement: compound_statement .

    $default  reduce using rule 52 (statement)


State 170

   48 var_const_stmt_list: var_const_stmt_list statement .

    $default  reduce using rule 48 (var_const_stmt_list)


State 171

   53 statement: simple_statement .

    $default  reduce using rule 53 (statement)


State 172

   54 statement: conditional_statement .

    $default  reduce using rule 54 (statement)


State 173

   55 statement: while_statement .

    $default  reduce using rule 55 (statement)


State 174

   70 while_statement: $@9 . DO compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    DO  shift, and go to state 190


State 175

   56 statement: for_statement .

    $default  reduce using rule 56 (statement)


State 176

   57 statement: function_invoke_statement .

    $default  reduce using rule 57 (statement)


State 177

   58 statement: jump_statement .

    $default  reduce using rule 58 (statement)


State 178

   59 simple_statement: variable_reference . ASSIGN_OP logical_expression SEMICOLON
   95 variable_reference: variable_reference . dimension

    ML_BRACE   shift, and go to state 91
    ASSIGN_OP  shift, and go to state 191

    dimension  go to state 92


State 179

   27 var_decl: scalar_type . identifier_list SEMICOLON

    ID  shift, and go to state 192

    identifier_list  go to state 20
    array_decl       go to state 21


State 180

   94 variable_reference: ID .

    $default  reduce using rule 94 (variable_reference)


State 181

   62 simple_statement: READ variable_reference . SEMICOLON
   95 variable_reference: variable_reference . dimension

    SEMICOLON  shift, and go to state 193
    ML_BRACE   shift, and go to state 91

    dimension  go to state 92


State 182

   68 while_statement: WHILE L_PAREN . logical_expression $@7 R_PAREN $@8 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 194
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 183

   63 conditional_statement: IF L_PAREN . conditional_if R_PAREN compound_statement
   64                      | IF L_PAREN . conditional_if R_PAREN compound_statement ELSE compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    conditional_if         go to state 195
    variable_reference     go to state 55
    logical_expression     go to state 196
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 184

   72 for_statement: FOR L_PAREN . initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@10 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 77 (initial_expression)

    initial_expression     go to state 197
    statement_for          go to state 198
    variable_reference     go to state 199
    logical_expression     go to state 200
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 185

   61 simple_statement: PRINT $@6 . logical_expression SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 201
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 186

   91 jump_statement: CONTINUE SEMICOLON .

    $default  reduce using rule 91 (jump_statement)


State 187

   92 jump_statement: BREAK SEMICOLON .

    $default  reduce using rule 92 (jump_statement)


State 188

   93 jump_statement: RETURN logical_expression . SEMICOLON
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 93
    SEMICOLON  shift, and go to state 202


State 189

   89 function_invoke_statement: ID L_PAREN . logical_expression_list R_PAREN SEMICOLON
   90                          | ID L_PAREN . R_PAREN SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    R_PAREN      shift, and go to state 203
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 127
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 204
    literal_const            go to state 63


State 190

   70 while_statement: $@9 DO . compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 205
    $@5                 go to state 115


State 191

   59 simple_statement: variable_reference ASSIGN_OP . logical_expression SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 206
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 192

   34 identifier_list: ID . ASSIGN_OP logical_expression
   35                | ID .
   43 array_decl: ID . dim

    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 31

    $default  reduce using rule 35 (identifier_list)

    dim  go to state 32


State 193

   62 simple_statement: READ variable_reference SEMICOLON .

    $default  reduce using rule 62 (simple_statement)


State 194

   68 while_statement: WHILE L_PAREN logical_expression . $@7 R_PAREN $@8 compound_statement
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 66 ($@7)

    $@7  go to state 207


State 195

   63 conditional_statement: IF L_PAREN conditional_if . R_PAREN compound_statement
   64                      | IF L_PAREN conditional_if . R_PAREN compound_statement ELSE compound_statement

    R_PAREN  shift, and go to state 208


State 196

   65 conditional_if: logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 65 (conditional_if)


State 197

   72 for_statement: FOR L_PAREN initial_expression . SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@10 compound_statement
   73 initial_expression: initial_expression . COMMA statement_for
   74                   | initial_expression . COMMA logical_expression

    COMMA      shift, and go to state 209
    SEMICOLON  shift, and go to state 210


State 198

   76 initial_expression: statement_for .

    $default  reduce using rule 76 (initial_expression)


State 199

   88 statement_for: variable_reference . ASSIGN_OP logical_expression
   95 variable_reference: variable_reference . dimension
  121 factor: variable_reference .

    ML_BRACE   shift, and go to state 91
    ASSIGN_OP  shift, and go to state 211

    $default  reduce using rule 121 (factor)

    dimension  go to state 92


State 200

   75 initial_expression: logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 75 (initial_expression)


State 201

   61 simple_statement: PRINT $@6 logical_expression . SEMICOLON
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 93
    SEMICOLON  shift, and go to state 212


State 202

   93 jump_statement: RETURN logical_expression SEMICOLON .

    $default  reduce using rule 93 (jump_statement)


State 203

   90 function_invoke_statement: ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 213


State 204

   89 function_invoke_statement: ID L_PAREN logical_expression_list . R_PAREN SEMICOLON
  130 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 214
    COMMA    shift, and go to state 151


State 205

   70 while_statement: $@9 DO compound_statement . WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    WHILE  shift, and go to state 215


State 206

   59 simple_statement: variable_reference ASSIGN_OP logical_expression . SEMICOLON
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 93
    SEMICOLON  shift, and go to state 216


State 207

   68 while_statement: WHILE L_PAREN logical_expression $@7 . R_PAREN $@8 compound_statement

    R_PAREN  shift, and go to state 217


State 208

   63 conditional_statement: IF L_PAREN conditional_if R_PAREN . compound_statement
   64                      | IF L_PAREN conditional_if R_PAREN . compound_statement ELSE compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 218
    $@5                 go to state 115


State 209

   73 initial_expression: initial_expression COMMA . statement_for
   74                   | initial_expression COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    statement_for          go to state 219
    variable_reference     go to state 199
    logical_expression     go to state 220
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 210

   72 for_statement: FOR L_PAREN initial_expression SEMICOLON . control_expression SEMICOLON increment_expression R_PAREN $@10 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 82 (control_expression)

    control_expression     go to state 221
    statement_for          go to state 222
    variable_reference     go to state 199
    logical_expression     go to state 223
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 211

   88 statement_for: variable_reference ASSIGN_OP . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 224
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 212

   61 simple_statement: PRINT $@6 logical_expression SEMICOLON .

    $default  reduce using rule 61 (simple_statement)


State 213

   90 function_invoke_statement: ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 90 (function_invoke_statement)


State 214

   89 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 225


State 215

   70 while_statement: $@9 DO compound_statement WHILE . L_PAREN logical_expression R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 226


State 216

   59 simple_statement: variable_reference ASSIGN_OP logical_expression SEMICOLON .

    $default  reduce using rule 59 (simple_statement)


State 217

   68 while_statement: WHILE L_PAREN logical_expression $@7 R_PAREN . $@8 compound_statement

    $default  reduce using rule 67 ($@8)

    $@8  go to state 227


State 218

   63 conditional_statement: IF L_PAREN conditional_if R_PAREN compound_statement .
   64                      | IF L_PAREN conditional_if R_PAREN compound_statement . ELSE compound_statement

    ELSE  shift, and go to state 228

    $default  reduce using rule 63 (conditional_statement)


State 219

   73 initial_expression: initial_expression COMMA statement_for .

    $default  reduce using rule 73 (initial_expression)


State 220

   74 initial_expression: initial_expression COMMA logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 74 (initial_expression)


State 221

   72 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression . SEMICOLON increment_expression R_PAREN $@10 compound_statement
   78 control_expression: control_expression . COMMA statement_for
   79                   | control_expression . COMMA logical_expression

    COMMA      shift, and go to state 229
    SEMICOLON  shift, and go to state 230


State 222

   81 control_expression: statement_for .

    $default  reduce using rule 81 (control_expression)


State 223

   80 control_expression: logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 80 (control_expression)


State 224

   88 statement_for: variable_reference ASSIGN_OP logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 88 (statement_for)


State 225

   89 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN SEMICOLON .

    $default  reduce using rule 89 (function_invoke_statement)


State 226

   70 while_statement: $@9 DO compound_statement WHILE L_PAREN . logical_expression R_PAREN SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 231
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 227

   68 while_statement: WHILE L_PAREN logical_expression $@7 R_PAREN $@8 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 232
    $@5                 go to state 115


State 228

   64 conditional_statement: IF L_PAREN conditional_if R_PAREN compound_statement ELSE . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 233
    $@5                 go to state 115


State 229

   78 control_expression: control_expression COMMA . statement_for
   79                   | control_expression COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    statement_for          go to state 234
    variable_reference     go to state 199
    logical_expression     go to state 235
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 230

   72 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON . increment_expression R_PAREN $@10 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 87 (increment_expression)

    increment_expression   go to state 236
    statement_for          go to state 237
    variable_reference     go to state 199
    logical_expression     go to state 238
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 231

   70 while_statement: $@9 DO compound_statement WHILE L_PAREN logical_expression . R_PAREN SEMICOLON
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP    shift, and go to state 93
    R_PAREN  shift, and go to state 239


State 232

   68 while_statement: WHILE L_PAREN logical_expression $@7 R_PAREN $@8 compound_statement .

    $default  reduce using rule 68 (while_statement)


State 233

   64 conditional_statement: IF L_PAREN conditional_if R_PAREN compound_statement ELSE compound_statement .

    $default  reduce using rule 64 (conditional_statement)


State 234

   78 control_expression: control_expression COMMA statement_for .

    $default  reduce using rule 78 (control_expression)


State 235

   79 control_expression: control_expression COMMA logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 79 (control_expression)


State 236

   72 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression . R_PAREN $@10 compound_statement
   83 increment_expression: increment_expression . COMMA statement_for
   84                     | increment_expression . COMMA logical_expression

    R_PAREN  shift, and go to state 240
    COMMA    shift, and go to state 241


State 237

   86 increment_expression: statement_for .

    $default  reduce using rule 86 (increment_expression)


State 238

   85 increment_expression: logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 85 (increment_expression)


State 239

   70 while_statement: $@9 DO compound_statement WHILE L_PAREN logical_expression R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 242


State 240

   72 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN . $@10 compound_statement

    $default  reduce using rule 71 ($@10)

    $@10  go to state 243


State 241

   83 increment_expression: increment_expression COMMA . statement_for
   84                     | increment_expression COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    statement_for          go to state 244
    variable_reference     go to state 199
    logical_expression     go to state 245
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 242

   70 while_statement: $@9 DO compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON .

    $default  reduce using rule 70 (while_statement)


State 243

   72 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@10 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 246
    $@5                 go to state 115


State 244

   83 increment_expression: increment_expression COMMA statement_for .

    $default  reduce using rule 83 (increment_expression)


State 245

   84 increment_expression: increment_expression COMMA logical_expression .
   97 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 84 (increment_expression)


State 246

   72 for_statement: FOR L_PAREN initial_expression SEMICOLON control_expression SEMICOLON increment_expression R_PAREN $@10 compound_statement .

    $default  reduce using rule 72 (for_statement)
