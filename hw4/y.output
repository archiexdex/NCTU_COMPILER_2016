Terminals unused in grammar

   BOOLEAN


Rules useless in parser due to conflicts

   65 $@8: %empty


State 59 conflicts: 6 reduce/reduce
State 60 conflicts: 8 shift/reduce
State 130 conflicts: 9 shift/reduce
State 133 conflicts: 8 shift/reduce, 15 reduce/reduce
State 183 conflicts: 10 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: decl_list funct_def decl_and_def_list

    2 decl_list: decl_list var_decl
    3          | decl_list const_decl
    4          | decl_list funct_decl
    5          | %empty

    6 decl_and_def_list: decl_and_def_list var_decl
    7                  | decl_and_def_list const_decl
    8                  | decl_and_def_list funct_decl
    9                  | decl_and_def_list funct_def
   10                  | %empty

   11 $@1: %empty

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 compound_statement

   13 $@2: %empty

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 compound_statement

   15 $@3: %empty

   16 funct_def: VOID ID L_PAREN R_PAREN $@3 compound_statement

   17 $@4: %empty

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@4 compound_statement

   19 funct_decl: scalar_type ID L_PAREN R_PAREN SEMICOLON
   20           | scalar_type ID L_PAREN parameter_list R_PAREN SEMICOLON
   21           | VOID ID L_PAREN R_PAREN SEMICOLON
   22           | VOID ID L_PAREN parameter_list R_PAREN SEMICOLON

   23 parameter_list: parameter_list COMMA scalar_type ID
   24               | parameter_list COMMA scalar_type array_decl
   25               | scalar_type array_decl
   26               | scalar_type ID

   27 var_decl: scalar_type identifier_list SEMICOLON

   28 identifier_list: identifier_list COMMA ID
   29                | identifier_list COMMA ID ASSIGN_OP logical_expression
   30                | identifier_list COMMA array_decl ASSIGN_OP initial_array
   31                | identifier_list COMMA array_decl
   32                | array_decl ASSIGN_OP initial_array
   33                | array_decl
   34                | ID ASSIGN_OP logical_expression
   35                | ID

   36 initial_array: L_BRACE literal_list R_BRACE

   37 literal_list: literal_list COMMA logical_expression
   38             | logical_expression
   39             | %empty

   40 const_decl: CONST scalar_type const_list SEMICOLON

   41 const_list: const_list COMMA ID ASSIGN_OP literal_const
   42           | ID ASSIGN_OP literal_const

   43 array_decl: ID dim

   44 dim: dim ML_BRACE INT_CONST MR_BRACE
   45    | ML_BRACE INT_CONST MR_BRACE

   46 $@5: %empty

   47 compound_statement: $@5 L_BRACE var_const_stmt_list R_BRACE

   48 var_const_stmt_list: var_const_stmt_list statement
   49                    | var_const_stmt_list var_decl
   50                    | var_const_stmt_list const_decl
   51                    | %empty

   52 statement: compound_statement
   53          | simple_statement
   54          | conditional_statement
   55          | while_statement
   56          | for_statement
   57          | function_invoke_statement
   58          | jump_statement

   59 simple_statement: variable_reference ASSIGN_OP logical_expression SEMICOLON

   60 $@6: %empty

   61 simple_statement: PRINT $@6 logical_expression SEMICOLON
   62                 | READ variable_reference SEMICOLON

   63 $@7: %empty

   64 conditional_statement: IF L_PAREN $@7 conditional_if R_PAREN compound_statement

   65 $@8: %empty

   66 $@9: %empty

   67 conditional_statement: IF L_PAREN $@8 conditional_if R_PAREN compound_statement $@9 ELSE compound_statement

   68 conditional_if: logical_expression

   69 $@10: %empty

   70 $@11: %empty

   71 $@12: %empty

   72 while_statement: WHILE L_PAREN $@10 logical_expression $@11 R_PAREN $@12 compound_statement

   73 $@13: %empty

   74 while_statement: $@13 DO compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON

   75 $@14: %empty

   76 $@15: %empty

   77 $@16: %empty

   78 $@17: %empty

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON $@14 control_expression SEMICOLON $@15 increment_expression $@16 R_PAREN $@17 compound_statement

   80 initial_expression: initial_expression COMMA statement_for
   81                   | initial_expression COMMA logical_expression
   82                   | logical_expression
   83                   | statement_for
   84                   | %empty

   85 control_expression: control_expression COMMA statement_for
   86                   | control_expression COMMA logical_expression
   87                   | logical_expression
   88                   | statement_for
   89                   | %empty

   90 increment_expression: increment_expression COMMA statement_for
   91                     | increment_expression COMMA logical_expression
   92                     | logical_expression
   93                     | statement_for
   94                     | %empty

   95 statement_for: variable_reference ASSIGN_OP logical_expression

   96 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN SEMICOLON
   97                          | ID L_PAREN R_PAREN SEMICOLON

   98 jump_statement: CONTINUE SEMICOLON
   99               | BREAK SEMICOLON
  100               | RETURN logical_expression SEMICOLON

  101 variable_reference: ID
  102                   | variable_reference dimension

  103 dimension: ML_BRACE arithmetic_expression MR_BRACE

  104 logical_expression: logical_expression OR_OP logical_term
  105                   | logical_term

  106 logical_term: logical_term AND_OP logical_factor
  107             | logical_factor

  108 logical_factor: NOT_OP logical_factor
  109               | relation_expression

  110 relation_expression: arithmetic_expression relation_operator arithmetic_expression
  111                    | arithmetic_expression

  112 relation_operator: LT_OP
  113                  | LE_OP
  114                  | EQ_OP
  115                  | GE_OP
  116                  | GT_OP
  117                  | NE_OP

  118 arithmetic_expression: arithmetic_expression add_op term
  119                      | relation_expression
  120                      | term

  121 add_op: ADD_OP
  122       | SUB_OP

  123 term: term mul_op factor
  124     | factor

  125 mul_op: MUL_OP
  126       | DIV_OP
  127       | MOD_OP

  128 factor: variable_reference
  129       | SUB_OP variable_reference
  130       | L_PAREN logical_expression R_PAREN
  131       | SUB_OP L_PAREN logical_expression R_PAREN
  132       | ID L_PAREN logical_expression_list R_PAREN
  133       | SUB_OP ID L_PAREN logical_expression_list R_PAREN
  134       | ID L_PAREN R_PAREN
  135       | SUB_OP ID L_PAREN R_PAREN
  136       | literal_const

  137 logical_expression_list: logical_expression_list COMMA logical_expression
  138                        | logical_expression

  139 scalar_type: INT
  140            | DOUBLE
  141            | STRING
  142            | BOOL
  143            | FLOAT

  144 literal_const: INT_CONST
  145              | SUB_OP INT_CONST
  146              | FLOAT_CONST
  147              | SUB_OP FLOAT_CONST
  148              | SCIENTIFIC
  149              | SUB_OP SCIENTIFIC
  150              | STR_CONST
  151              | TRUE
  152              | FALSE


Terminals, with rules where they appear

$end (0) 0
error (256)
LE_OP (258) 113
NE_OP (259) 117
GE_OP (260) 115
EQ_OP (261) 114
AND_OP (262) 106
OR_OP (263) 104
READ (264) 62
BOOLEAN (265)
WHILE (266) 72 74
DO (267) 74
IF (268) 64 67
ELSE (269) 67
TRUE (270) 151
FALSE (271) 152
FOR (272) 79
INT (273) 139
PRINT (274) 61
BOOL (275) 142
VOID (276) 16 18 21 22
FLOAT (277) 143
DOUBLE (278) 140
STRING (279) 141
CONTINUE (280) 98
BREAK (281) 99
RETURN (282) 100
CONST (283) 40
L_PAREN (284) 12 14 16 18 19 20 21 22 64 67 72 74 79 96 97 130 131
    132 133 134 135
R_PAREN (285) 12 14 16 18 19 20 21 22 64 67 72 74 79 96 97 130 131
    132 133 134 135
COMMA (286) 23 24 28 29 30 31 37 41 80 81 85 86 90 91 137
SEMICOLON (287) 19 20 21 22 27 40 59 61 62 74 79 96 97 98 99 100
ML_BRACE (288) 44 45 103
MR_BRACE (289) 44 45 103
L_BRACE (290) 36 47
R_BRACE (291) 36 47
ADD_OP (292) 121
SUB_OP (293) 122 129 131 133 135 145 147 149
MUL_OP (294) 125
DIV_OP (295) 126
MOD_OP (296) 127
ASSIGN_OP (297) 29 30 32 34 41 42 59 95
LT_OP (298) 112
GT_OP (299) 116
NOT_OP (300) 108
ID (301) 12 14 16 18 19 20 21 22 23 26 28 29 34 35 41 42 43 96 97 101
    132 133 134 135
INT_CONST (302) 44 45 144 145
FLOAT_CONST (303) 146 147
SCIENTIFIC (304) 148 149
STR_CONST (305) 150


Nonterminals, with rules where they appear

$accept (51)
    on left: 0
program (52)
    on left: 1, on right: 0
decl_list (53)
    on left: 2 3 4 5, on right: 1 2 3 4
decl_and_def_list (54)
    on left: 6 7 8 9 10, on right: 1 6 7 8 9
funct_def (55)
    on left: 12 14 16 18, on right: 1 9
$@1 (56)
    on left: 11, on right: 12
$@2 (57)
    on left: 13, on right: 14
$@3 (58)
    on left: 15, on right: 16
$@4 (59)
    on left: 17, on right: 18
funct_decl (60)
    on left: 19 20 21 22, on right: 4 8
parameter_list (61)
    on left: 23 24 25 26, on right: 14 18 20 22 23 24
var_decl (62)
    on left: 27, on right: 2 6 49
identifier_list (63)
    on left: 28 29 30 31 32 33 34 35, on right: 27 28 29 30 31
initial_array (64)
    on left: 36, on right: 30 32
literal_list (65)
    on left: 37 38 39, on right: 36 37
const_decl (66)
    on left: 40, on right: 3 7 50
const_list (67)
    on left: 41 42, on right: 40 41
array_decl (68)
    on left: 43, on right: 24 25 30 31 32 33
dim (69)
    on left: 44 45, on right: 43 44
compound_statement (70)
    on left: 47, on right: 12 14 16 18 52 64 67 72 74 79
$@5 (71)
    on left: 46, on right: 47
var_const_stmt_list (72)
    on left: 48 49 50 51, on right: 47 48 49 50
statement (73)
    on left: 52 53 54 55 56 57 58, on right: 48
simple_statement (74)
    on left: 59 61 62, on right: 53
$@6 (75)
    on left: 60, on right: 61
conditional_statement (76)
    on left: 64 67, on right: 54
$@7 (77)
    on left: 63, on right: 64
$@8 (78)
    on left: 65, on right: 67
$@9 (79)
    on left: 66, on right: 67
conditional_if (80)
    on left: 68, on right: 64 67
while_statement (81)
    on left: 72 74, on right: 55
$@10 (82)
    on left: 69, on right: 72
$@11 (83)
    on left: 70, on right: 72
$@12 (84)
    on left: 71, on right: 72
$@13 (85)
    on left: 73, on right: 74
for_statement (86)
    on left: 79, on right: 56
$@14 (87)
    on left: 75, on right: 79
$@15 (88)
    on left: 76, on right: 79
$@16 (89)
    on left: 77, on right: 79
$@17 (90)
    on left: 78, on right: 79
initial_expression (91)
    on left: 80 81 82 83 84, on right: 79 80 81
control_expression (92)
    on left: 85 86 87 88 89, on right: 79 85 86
increment_expression (93)
    on left: 90 91 92 93 94, on right: 79 90 91
statement_for (94)
    on left: 95, on right: 80 83 85 88 90 93
function_invoke_statement (95)
    on left: 96 97, on right: 57
jump_statement (96)
    on left: 98 99 100, on right: 58
variable_reference (97)
    on left: 101 102, on right: 59 62 95 102 128 129
dimension (98)
    on left: 103, on right: 102
logical_expression (99)
    on left: 104 105, on right: 29 34 37 38 59 61 68 72 74 81 82 86
    87 91 92 95 100 104 130 131 137 138
logical_term (100)
    on left: 106 107, on right: 104 105 106
logical_factor (101)
    on left: 108 109, on right: 106 107 108
relation_expression (102)
    on left: 110 111, on right: 109 119
relation_operator (103)
    on left: 112 113 114 115 116 117, on right: 110
arithmetic_expression (104)
    on left: 118 119 120, on right: 103 110 111 118
add_op (105)
    on left: 121 122, on right: 118
term (106)
    on left: 123 124, on right: 118 120 123
mul_op (107)
    on left: 125 126 127, on right: 123
factor (108)
    on left: 128 129 130 131 132 133 134 135 136, on right: 123 124
logical_expression_list (109)
    on left: 137 138, on right: 96 132 133 137
scalar_type (110)
    on left: 139 140 141 142 143, on right: 12 14 19 20 23 24 25 26
    27 40
literal_const (111)
    on left: 144 145 146 147 148 149 150 151 152, on right: 41 42 136


State 0

    0 $accept: . program $end

    $default  reduce using rule 5 (decl_list)

    program    go to state 1
    decl_list  go to state 2


State 1

    0 $accept: program . $end

    $end  shift, and go to state 3


State 2

    1 program: decl_list . funct_def decl_and_def_list
    2 decl_list: decl_list . var_decl
    3          | decl_list . const_decl
    4          | decl_list . funct_decl

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    VOID    shift, and go to state 6
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9
    CONST   shift, and go to state 10

    funct_def    go to state 11
    funct_decl   go to state 12
    var_decl     go to state 13
    const_decl   go to state 14
    scalar_type  go to state 15


State 3

    0 $accept: program $end .

    $default  accept


State 4

  139 scalar_type: INT .

    $default  reduce using rule 139 (scalar_type)


State 5

  142 scalar_type: BOOL .

    $default  reduce using rule 142 (scalar_type)


State 6

   16 funct_def: VOID . ID L_PAREN R_PAREN $@3 compound_statement
   18          | VOID . ID L_PAREN parameter_list R_PAREN $@4 compound_statement
   21 funct_decl: VOID . ID L_PAREN R_PAREN SEMICOLON
   22           | VOID . ID L_PAREN parameter_list R_PAREN SEMICOLON

    ID  shift, and go to state 16


State 7

  143 scalar_type: FLOAT .

    $default  reduce using rule 143 (scalar_type)


State 8

  140 scalar_type: DOUBLE .

    $default  reduce using rule 140 (scalar_type)


State 9

  141 scalar_type: STRING .

    $default  reduce using rule 141 (scalar_type)


State 10

   40 const_decl: CONST . scalar_type const_list SEMICOLON

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9

    scalar_type  go to state 17


State 11

    1 program: decl_list funct_def . decl_and_def_list

    $default  reduce using rule 10 (decl_and_def_list)

    decl_and_def_list  go to state 18


State 12

    4 decl_list: decl_list funct_decl .

    $default  reduce using rule 4 (decl_list)


State 13

    2 decl_list: decl_list var_decl .

    $default  reduce using rule 2 (decl_list)


State 14

    3 decl_list: decl_list const_decl .

    $default  reduce using rule 3 (decl_list)


State 15

   12 funct_def: scalar_type . ID L_PAREN R_PAREN $@1 compound_statement
   14          | scalar_type . ID L_PAREN parameter_list R_PAREN $@2 compound_statement
   19 funct_decl: scalar_type . ID L_PAREN R_PAREN SEMICOLON
   20           | scalar_type . ID L_PAREN parameter_list R_PAREN SEMICOLON
   27 var_decl: scalar_type . identifier_list SEMICOLON

    ID  shift, and go to state 19

    identifier_list  go to state 20
    array_decl       go to state 21


State 16

   16 funct_def: VOID ID . L_PAREN R_PAREN $@3 compound_statement
   18          | VOID ID . L_PAREN parameter_list R_PAREN $@4 compound_statement
   21 funct_decl: VOID ID . L_PAREN R_PAREN SEMICOLON
   22           | VOID ID . L_PAREN parameter_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 22


State 17

   40 const_decl: CONST scalar_type . const_list SEMICOLON

    ID  shift, and go to state 23

    const_list  go to state 24


State 18

    1 program: decl_list funct_def decl_and_def_list .
    6 decl_and_def_list: decl_and_def_list . var_decl
    7                  | decl_and_def_list . const_decl
    8                  | decl_and_def_list . funct_decl
    9                  | decl_and_def_list . funct_def

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    VOID    shift, and go to state 6
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9
    CONST   shift, and go to state 10

    $default  reduce using rule 1 (program)

    funct_def    go to state 25
    funct_decl   go to state 26
    var_decl     go to state 27
    const_decl   go to state 28
    scalar_type  go to state 15


State 19

   12 funct_def: scalar_type ID . L_PAREN R_PAREN $@1 compound_statement
   14          | scalar_type ID . L_PAREN parameter_list R_PAREN $@2 compound_statement
   19 funct_decl: scalar_type ID . L_PAREN R_PAREN SEMICOLON
   20           | scalar_type ID . L_PAREN parameter_list R_PAREN SEMICOLON
   34 identifier_list: ID . ASSIGN_OP logical_expression
   35                | ID .
   43 array_decl: ID . dim

    L_PAREN    shift, and go to state 29
    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 31

    $default  reduce using rule 35 (identifier_list)

    dim  go to state 32


State 20

   27 var_decl: scalar_type identifier_list . SEMICOLON
   28 identifier_list: identifier_list . COMMA ID
   29                | identifier_list . COMMA ID ASSIGN_OP logical_expression
   30                | identifier_list . COMMA array_decl ASSIGN_OP initial_array
   31                | identifier_list . COMMA array_decl

    COMMA      shift, and go to state 33
    SEMICOLON  shift, and go to state 34


State 21

   32 identifier_list: array_decl . ASSIGN_OP initial_array
   33                | array_decl .

    ASSIGN_OP  shift, and go to state 35

    $default  reduce using rule 33 (identifier_list)


State 22

   16 funct_def: VOID ID L_PAREN . R_PAREN $@3 compound_statement
   18          | VOID ID L_PAREN . parameter_list R_PAREN $@4 compound_statement
   21 funct_decl: VOID ID L_PAREN . R_PAREN SEMICOLON
   22           | VOID ID L_PAREN . parameter_list R_PAREN SEMICOLON

    INT      shift, and go to state 4
    BOOL     shift, and go to state 5
    FLOAT    shift, and go to state 7
    DOUBLE   shift, and go to state 8
    STRING   shift, and go to state 9
    R_PAREN  shift, and go to state 36

    parameter_list  go to state 37
    scalar_type     go to state 38


State 23

   42 const_list: ID . ASSIGN_OP literal_const

    ASSIGN_OP  shift, and go to state 39


State 24

   40 const_decl: CONST scalar_type const_list . SEMICOLON
   41 const_list: const_list . COMMA ID ASSIGN_OP literal_const

    COMMA      shift, and go to state 40
    SEMICOLON  shift, and go to state 41


State 25

    9 decl_and_def_list: decl_and_def_list funct_def .

    $default  reduce using rule 9 (decl_and_def_list)


State 26

    8 decl_and_def_list: decl_and_def_list funct_decl .

    $default  reduce using rule 8 (decl_and_def_list)


State 27

    6 decl_and_def_list: decl_and_def_list var_decl .

    $default  reduce using rule 6 (decl_and_def_list)


State 28

    7 decl_and_def_list: decl_and_def_list const_decl .

    $default  reduce using rule 7 (decl_and_def_list)


State 29

   12 funct_def: scalar_type ID L_PAREN . R_PAREN $@1 compound_statement
   14          | scalar_type ID L_PAREN . parameter_list R_PAREN $@2 compound_statement
   19 funct_decl: scalar_type ID L_PAREN . R_PAREN SEMICOLON
   20           | scalar_type ID L_PAREN . parameter_list R_PAREN SEMICOLON

    INT      shift, and go to state 4
    BOOL     shift, and go to state 5
    FLOAT    shift, and go to state 7
    DOUBLE   shift, and go to state 8
    STRING   shift, and go to state 9
    R_PAREN  shift, and go to state 42

    parameter_list  go to state 43
    scalar_type     go to state 38


State 30

   45 dim: ML_BRACE . INT_CONST MR_BRACE

    INT_CONST  shift, and go to state 44


State 31

   34 identifier_list: ID ASSIGN_OP . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 56
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 32

   43 array_decl: ID dim .
   44 dim: dim . ML_BRACE INT_CONST MR_BRACE

    ML_BRACE  shift, and go to state 64

    $default  reduce using rule 43 (array_decl)


State 33

   28 identifier_list: identifier_list COMMA . ID
   29                | identifier_list COMMA . ID ASSIGN_OP logical_expression
   30                | identifier_list COMMA . array_decl ASSIGN_OP initial_array
   31                | identifier_list COMMA . array_decl

    ID  shift, and go to state 65

    array_decl  go to state 66


State 34

   27 var_decl: scalar_type identifier_list SEMICOLON .

    $default  reduce using rule 27 (var_decl)


State 35

   32 identifier_list: array_decl ASSIGN_OP . initial_array

    L_BRACE  shift, and go to state 67

    initial_array  go to state 68


State 36

   16 funct_def: VOID ID L_PAREN R_PAREN . $@3 compound_statement
   21 funct_decl: VOID ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 69

    $default  reduce using rule 15 ($@3)

    $@3  go to state 70


State 37

   18 funct_def: VOID ID L_PAREN parameter_list . R_PAREN $@4 compound_statement
   22 funct_decl: VOID ID L_PAREN parameter_list . R_PAREN SEMICOLON
   23 parameter_list: parameter_list . COMMA scalar_type ID
   24               | parameter_list . COMMA scalar_type array_decl

    R_PAREN  shift, and go to state 71
    COMMA    shift, and go to state 72


State 38

   25 parameter_list: scalar_type . array_decl
   26               | scalar_type . ID

    ID  shift, and go to state 73

    array_decl  go to state 74


State 39

   42 const_list: ID ASSIGN_OP . literal_const

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    SUB_OP       shift, and go to state 75
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    literal_const  go to state 76


State 40

   41 const_list: const_list COMMA . ID ASSIGN_OP literal_const

    ID  shift, and go to state 77


State 41

   40 const_decl: CONST scalar_type const_list SEMICOLON .

    $default  reduce using rule 40 (const_decl)


State 42

   12 funct_def: scalar_type ID L_PAREN R_PAREN . $@1 compound_statement
   19 funct_decl: scalar_type ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 78

    $default  reduce using rule 11 ($@1)

    $@1  go to state 79


State 43

   14 funct_def: scalar_type ID L_PAREN parameter_list . R_PAREN $@2 compound_statement
   20 funct_decl: scalar_type ID L_PAREN parameter_list . R_PAREN SEMICOLON
   23 parameter_list: parameter_list . COMMA scalar_type ID
   24               | parameter_list . COMMA scalar_type array_decl

    R_PAREN  shift, and go to state 80
    COMMA    shift, and go to state 72


State 44

   45 dim: ML_BRACE INT_CONST . MR_BRACE

    MR_BRACE  shift, and go to state 81


State 45

  151 literal_const: TRUE .

    $default  reduce using rule 151 (literal_const)


State 46

  152 literal_const: FALSE .

    $default  reduce using rule 152 (literal_const)


State 47

  130 factor: L_PAREN . logical_expression R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 82
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 48

  129 factor: SUB_OP . variable_reference
  131       | SUB_OP . L_PAREN logical_expression R_PAREN
  133       | SUB_OP . ID L_PAREN logical_expression_list R_PAREN
  135       | SUB_OP . ID L_PAREN R_PAREN
  145 literal_const: SUB_OP . INT_CONST
  147              | SUB_OP . FLOAT_CONST
  149              | SUB_OP . SCIENTIFIC

    L_PAREN      shift, and go to state 83
    ID           shift, and go to state 84
    INT_CONST    shift, and go to state 85
    FLOAT_CONST  shift, and go to state 86
    SCIENTIFIC   shift, and go to state 87

    variable_reference  go to state 88


State 49

  108 logical_factor: NOT_OP . logical_factor

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_factor         go to state 89
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 50

  101 variable_reference: ID .
  132 factor: ID . L_PAREN logical_expression_list R_PAREN
  134       | ID . L_PAREN R_PAREN

    L_PAREN  shift, and go to state 90

    $default  reduce using rule 101 (variable_reference)


State 51

  144 literal_const: INT_CONST .

    $default  reduce using rule 144 (literal_const)


State 52

  146 literal_const: FLOAT_CONST .

    $default  reduce using rule 146 (literal_const)


State 53

  148 literal_const: SCIENTIFIC .

    $default  reduce using rule 148 (literal_const)


State 54

  150 literal_const: STR_CONST .

    $default  reduce using rule 150 (literal_const)


State 55

  102 variable_reference: variable_reference . dimension
  128 factor: variable_reference .

    ML_BRACE  shift, and go to state 91

    $default  reduce using rule 128 (factor)

    dimension  go to state 92


State 56

   34 identifier_list: ID ASSIGN_OP logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 34 (identifier_list)


State 57

  105 logical_expression: logical_term .
  106 logical_term: logical_term . AND_OP logical_factor

    AND_OP  shift, and go to state 94

    $default  reduce using rule 105 (logical_expression)


State 58

  107 logical_term: logical_factor .

    $default  reduce using rule 107 (logical_term)


State 59

  109 logical_factor: relation_expression .
  119 arithmetic_expression: relation_expression .

    AND_OP     reduce using rule 109 (logical_factor)
    AND_OP     [reduce using rule 119 (arithmetic_expression)]
    OR_OP      reduce using rule 109 (logical_factor)
    OR_OP      [reduce using rule 119 (arithmetic_expression)]
    R_PAREN    reduce using rule 109 (logical_factor)
    R_PAREN    [reduce using rule 119 (arithmetic_expression)]
    COMMA      reduce using rule 109 (logical_factor)
    COMMA      [reduce using rule 119 (arithmetic_expression)]
    SEMICOLON  reduce using rule 109 (logical_factor)
    SEMICOLON  [reduce using rule 119 (arithmetic_expression)]
    R_BRACE    reduce using rule 109 (logical_factor)
    R_BRACE    [reduce using rule 119 (arithmetic_expression)]
    $default   reduce using rule 119 (arithmetic_expression)


State 60

  110 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  111                    | arithmetic_expression .
  118 arithmetic_expression: arithmetic_expression . add_op term

    LE_OP   shift, and go to state 95
    NE_OP   shift, and go to state 96
    GE_OP   shift, and go to state 97
    EQ_OP   shift, and go to state 98
    ADD_OP  shift, and go to state 99
    SUB_OP  shift, and go to state 100
    LT_OP   shift, and go to state 101
    GT_OP   shift, and go to state 102

    LE_OP     [reduce using rule 111 (relation_expression)]
    NE_OP     [reduce using rule 111 (relation_expression)]
    GE_OP     [reduce using rule 111 (relation_expression)]
    EQ_OP     [reduce using rule 111 (relation_expression)]
    ADD_OP    [reduce using rule 111 (relation_expression)]
    SUB_OP    [reduce using rule 111 (relation_expression)]
    LT_OP     [reduce using rule 111 (relation_expression)]
    GT_OP     [reduce using rule 111 (relation_expression)]
    $default  reduce using rule 111 (relation_expression)

    relation_operator  go to state 103
    add_op             go to state 104


State 61

  120 arithmetic_expression: term .
  123 term: term . mul_op factor

    MUL_OP  shift, and go to state 105
    DIV_OP  shift, and go to state 106
    MOD_OP  shift, and go to state 107

    $default  reduce using rule 120 (arithmetic_expression)

    mul_op  go to state 108


State 62

  124 term: factor .

    $default  reduce using rule 124 (term)


State 63

  136 factor: literal_const .

    $default  reduce using rule 136 (factor)


State 64

   44 dim: dim ML_BRACE . INT_CONST MR_BRACE

    INT_CONST  shift, and go to state 109


State 65

   28 identifier_list: identifier_list COMMA ID .
   29                | identifier_list COMMA ID . ASSIGN_OP logical_expression
   43 array_decl: ID . dim

    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 110

    $default  reduce using rule 28 (identifier_list)

    dim  go to state 32


State 66

   30 identifier_list: identifier_list COMMA array_decl . ASSIGN_OP initial_array
   31                | identifier_list COMMA array_decl .

    ASSIGN_OP  shift, and go to state 111

    $default  reduce using rule 31 (identifier_list)


State 67

   36 initial_array: L_BRACE . literal_list R_BRACE

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 39 (literal_list)

    literal_list           go to state 112
    variable_reference     go to state 55
    logical_expression     go to state 113
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 68

   32 identifier_list: array_decl ASSIGN_OP initial_array .

    $default  reduce using rule 32 (identifier_list)


State 69

   21 funct_decl: VOID ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 21 (funct_decl)


State 70

   16 funct_def: VOID ID L_PAREN R_PAREN $@3 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 114
    $@5                 go to state 115


State 71

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN . $@4 compound_statement
   22 funct_decl: VOID ID L_PAREN parameter_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 116

    $default  reduce using rule 17 ($@4)

    $@4  go to state 117


State 72

   23 parameter_list: parameter_list COMMA . scalar_type ID
   24               | parameter_list COMMA . scalar_type array_decl

    INT     shift, and go to state 4
    BOOL    shift, and go to state 5
    FLOAT   shift, and go to state 7
    DOUBLE  shift, and go to state 8
    STRING  shift, and go to state 9

    scalar_type  go to state 118


State 73

   26 parameter_list: scalar_type ID .
   43 array_decl: ID . dim

    ML_BRACE  shift, and go to state 30

    $default  reduce using rule 26 (parameter_list)

    dim  go to state 32


State 74

   25 parameter_list: scalar_type array_decl .

    $default  reduce using rule 25 (parameter_list)


State 75

  145 literal_const: SUB_OP . INT_CONST
  147              | SUB_OP . FLOAT_CONST
  149              | SUB_OP . SCIENTIFIC

    INT_CONST    shift, and go to state 85
    FLOAT_CONST  shift, and go to state 86
    SCIENTIFIC   shift, and go to state 87


State 76

   42 const_list: ID ASSIGN_OP literal_const .

    $default  reduce using rule 42 (const_list)


State 77

   41 const_list: const_list COMMA ID . ASSIGN_OP literal_const

    ASSIGN_OP  shift, and go to state 119


State 78

   19 funct_decl: scalar_type ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 19 (funct_decl)


State 79

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 120
    $@5                 go to state 115


State 80

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN . $@2 compound_statement
   20 funct_decl: scalar_type ID L_PAREN parameter_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 121

    $default  reduce using rule 13 ($@2)

    $@2  go to state 122


State 81

   45 dim: ML_BRACE INT_CONST MR_BRACE .

    $default  reduce using rule 45 (dim)


State 82

  104 logical_expression: logical_expression . OR_OP logical_term
  130 factor: L_PAREN logical_expression . R_PAREN

    OR_OP    shift, and go to state 93
    R_PAREN  shift, and go to state 123


State 83

  131 factor: SUB_OP L_PAREN . logical_expression R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 124
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 84

  101 variable_reference: ID .
  133 factor: SUB_OP ID . L_PAREN logical_expression_list R_PAREN
  135       | SUB_OP ID . L_PAREN R_PAREN

    L_PAREN  shift, and go to state 125

    $default  reduce using rule 101 (variable_reference)


State 85

  145 literal_const: SUB_OP INT_CONST .

    $default  reduce using rule 145 (literal_const)


State 86

  147 literal_const: SUB_OP FLOAT_CONST .

    $default  reduce using rule 147 (literal_const)


State 87

  149 literal_const: SUB_OP SCIENTIFIC .

    $default  reduce using rule 149 (literal_const)


State 88

  102 variable_reference: variable_reference . dimension
  129 factor: SUB_OP variable_reference .

    ML_BRACE  shift, and go to state 91

    $default  reduce using rule 129 (factor)

    dimension  go to state 92


State 89

  108 logical_factor: NOT_OP logical_factor .

    $default  reduce using rule 108 (logical_factor)


State 90

  132 factor: ID L_PAREN . logical_expression_list R_PAREN
  134       | ID L_PAREN . R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    R_PAREN      shift, and go to state 126
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 127
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 128
    literal_const            go to state 63


State 91

  103 dimension: ML_BRACE . arithmetic_expression MR_BRACE

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    relation_expression    go to state 129
    arithmetic_expression  go to state 130
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 92

  102 variable_reference: variable_reference dimension .

    $default  reduce using rule 102 (variable_reference)


State 93

  104 logical_expression: logical_expression OR_OP . logical_term

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_term           go to state 131
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 94

  106 logical_term: logical_term AND_OP . logical_factor

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_factor         go to state 132
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 95

  113 relation_operator: LE_OP .

    $default  reduce using rule 113 (relation_operator)


State 96

  117 relation_operator: NE_OP .

    $default  reduce using rule 117 (relation_operator)


State 97

  115 relation_operator: GE_OP .

    $default  reduce using rule 115 (relation_operator)


State 98

  114 relation_operator: EQ_OP .

    $default  reduce using rule 114 (relation_operator)


State 99

  121 add_op: ADD_OP .

    $default  reduce using rule 121 (add_op)


State 100

  122 add_op: SUB_OP .

    $default  reduce using rule 122 (add_op)


State 101

  112 relation_operator: LT_OP .

    $default  reduce using rule 112 (relation_operator)


State 102

  116 relation_operator: GT_OP .

    $default  reduce using rule 116 (relation_operator)


State 103

  110 relation_expression: arithmetic_expression relation_operator . arithmetic_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    relation_expression    go to state 129
    arithmetic_expression  go to state 133
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 104

  118 arithmetic_expression: arithmetic_expression add_op . term

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference  go to state 55
    term                go to state 134
    factor              go to state 62
    literal_const       go to state 63


State 105

  125 mul_op: MUL_OP .

    $default  reduce using rule 125 (mul_op)


State 106

  126 mul_op: DIV_OP .

    $default  reduce using rule 126 (mul_op)


State 107

  127 mul_op: MOD_OP .

    $default  reduce using rule 127 (mul_op)


State 108

  123 term: term mul_op . factor

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference  go to state 55
    factor              go to state 135
    literal_const       go to state 63


State 109

   44 dim: dim ML_BRACE INT_CONST . MR_BRACE

    MR_BRACE  shift, and go to state 136


State 110

   29 identifier_list: identifier_list COMMA ID ASSIGN_OP . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 137
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 111

   30 identifier_list: identifier_list COMMA array_decl ASSIGN_OP . initial_array

    L_BRACE  shift, and go to state 67

    initial_array  go to state 138


State 112

   36 initial_array: L_BRACE literal_list . R_BRACE
   37 literal_list: literal_list . COMMA logical_expression

    COMMA    shift, and go to state 139
    R_BRACE  shift, and go to state 140


State 113

   38 literal_list: logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 38 (literal_list)


State 114

   16 funct_def: VOID ID L_PAREN R_PAREN $@3 compound_statement .

    $default  reduce using rule 16 (funct_def)


State 115

   47 compound_statement: $@5 . L_BRACE var_const_stmt_list R_BRACE

    L_BRACE  shift, and go to state 141


State 116

   22 funct_decl: VOID ID L_PAREN parameter_list R_PAREN SEMICOLON .

    $default  reduce using rule 22 (funct_decl)


State 117

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@4 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 142
    $@5                 go to state 115


State 118

   23 parameter_list: parameter_list COMMA scalar_type . ID
   24               | parameter_list COMMA scalar_type . array_decl

    ID  shift, and go to state 143

    array_decl  go to state 144


State 119

   41 const_list: const_list COMMA ID ASSIGN_OP . literal_const

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    SUB_OP       shift, and go to state 75
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    literal_const  go to state 145


State 120

   12 funct_def: scalar_type ID L_PAREN R_PAREN $@1 compound_statement .

    $default  reduce using rule 12 (funct_def)


State 121

   20 funct_decl: scalar_type ID L_PAREN parameter_list R_PAREN SEMICOLON .

    $default  reduce using rule 20 (funct_decl)


State 122

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 146
    $@5                 go to state 115


State 123

  130 factor: L_PAREN logical_expression R_PAREN .

    $default  reduce using rule 130 (factor)


State 124

  104 logical_expression: logical_expression . OR_OP logical_term
  131 factor: SUB_OP L_PAREN logical_expression . R_PAREN

    OR_OP    shift, and go to state 93
    R_PAREN  shift, and go to state 147


State 125

  133 factor: SUB_OP ID L_PAREN . logical_expression_list R_PAREN
  135       | SUB_OP ID L_PAREN . R_PAREN

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    R_PAREN      shift, and go to state 148
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 127
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 149
    literal_const            go to state 63


State 126

  134 factor: ID L_PAREN R_PAREN .

    $default  reduce using rule 134 (factor)


State 127

  104 logical_expression: logical_expression . OR_OP logical_term
  138 logical_expression_list: logical_expression .

    OR_OP  shift, and go to state 93

    $default  reduce using rule 138 (logical_expression_list)


State 128

  132 factor: ID L_PAREN logical_expression_list . R_PAREN
  137 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 150
    COMMA    shift, and go to state 151


State 129

  119 arithmetic_expression: relation_expression .

    $default  reduce using rule 119 (arithmetic_expression)


State 130

  103 dimension: ML_BRACE arithmetic_expression . MR_BRACE
  110 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  111                    | arithmetic_expression .
  118 arithmetic_expression: arithmetic_expression . add_op term

    LE_OP     shift, and go to state 95
    NE_OP     shift, and go to state 96
    GE_OP     shift, and go to state 97
    EQ_OP     shift, and go to state 98
    MR_BRACE  shift, and go to state 152
    ADD_OP    shift, and go to state 99
    SUB_OP    shift, and go to state 100
    LT_OP     shift, and go to state 101
    GT_OP     shift, and go to state 102

    LE_OP     [reduce using rule 111 (relation_expression)]
    NE_OP     [reduce using rule 111 (relation_expression)]
    GE_OP     [reduce using rule 111 (relation_expression)]
    EQ_OP     [reduce using rule 111 (relation_expression)]
    MR_BRACE  [reduce using rule 111 (relation_expression)]
    ADD_OP    [reduce using rule 111 (relation_expression)]
    SUB_OP    [reduce using rule 111 (relation_expression)]
    LT_OP     [reduce using rule 111 (relation_expression)]
    GT_OP     [reduce using rule 111 (relation_expression)]

    relation_operator  go to state 103
    add_op             go to state 104


State 131

  104 logical_expression: logical_expression OR_OP logical_term .
  106 logical_term: logical_term . AND_OP logical_factor

    AND_OP  shift, and go to state 94

    $default  reduce using rule 104 (logical_expression)


State 132

  106 logical_term: logical_term AND_OP logical_factor .

    $default  reduce using rule 106 (logical_term)


State 133

  110 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
  110                    | arithmetic_expression relation_operator arithmetic_expression .
  111                    | arithmetic_expression .
  118 arithmetic_expression: arithmetic_expression . add_op term

    LE_OP   shift, and go to state 95
    NE_OP   shift, and go to state 96
    GE_OP   shift, and go to state 97
    EQ_OP   shift, and go to state 98
    ADD_OP  shift, and go to state 99
    SUB_OP  shift, and go to state 100
    LT_OP   shift, and go to state 101
    GT_OP   shift, and go to state 102

    LE_OP      [reduce using rule 110 (relation_expression)]
    LE_OP      [reduce using rule 111 (relation_expression)]
    NE_OP      [reduce using rule 110 (relation_expression)]
    NE_OP      [reduce using rule 111 (relation_expression)]
    GE_OP      [reduce using rule 110 (relation_expression)]
    GE_OP      [reduce using rule 111 (relation_expression)]
    EQ_OP      [reduce using rule 110 (relation_expression)]
    EQ_OP      [reduce using rule 111 (relation_expression)]
    AND_OP     reduce using rule 110 (relation_expression)
    AND_OP     [reduce using rule 111 (relation_expression)]
    OR_OP      reduce using rule 110 (relation_expression)
    OR_OP      [reduce using rule 111 (relation_expression)]
    R_PAREN    reduce using rule 110 (relation_expression)
    R_PAREN    [reduce using rule 111 (relation_expression)]
    COMMA      reduce using rule 110 (relation_expression)
    COMMA      [reduce using rule 111 (relation_expression)]
    SEMICOLON  reduce using rule 110 (relation_expression)
    SEMICOLON  [reduce using rule 111 (relation_expression)]
    MR_BRACE   reduce using rule 110 (relation_expression)
    MR_BRACE   [reduce using rule 111 (relation_expression)]
    R_BRACE    reduce using rule 110 (relation_expression)
    R_BRACE    [reduce using rule 111 (relation_expression)]
    ADD_OP     [reduce using rule 110 (relation_expression)]
    ADD_OP     [reduce using rule 111 (relation_expression)]
    SUB_OP     [reduce using rule 110 (relation_expression)]
    SUB_OP     [reduce using rule 111 (relation_expression)]
    LT_OP      [reduce using rule 110 (relation_expression)]
    LT_OP      [reduce using rule 111 (relation_expression)]
    GT_OP      [reduce using rule 110 (relation_expression)]
    GT_OP      [reduce using rule 111 (relation_expression)]
    $default   reduce using rule 110 (relation_expression)

    relation_operator  go to state 103
    add_op             go to state 104


State 134

  118 arithmetic_expression: arithmetic_expression add_op term .
  123 term: term . mul_op factor

    MUL_OP  shift, and go to state 105
    DIV_OP  shift, and go to state 106
    MOD_OP  shift, and go to state 107

    $default  reduce using rule 118 (arithmetic_expression)

    mul_op  go to state 108


State 135

  123 term: term mul_op factor .

    $default  reduce using rule 123 (term)


State 136

   44 dim: dim ML_BRACE INT_CONST MR_BRACE .

    $default  reduce using rule 44 (dim)


State 137

   29 identifier_list: identifier_list COMMA ID ASSIGN_OP logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 29 (identifier_list)


State 138

   30 identifier_list: identifier_list COMMA array_decl ASSIGN_OP initial_array .

    $default  reduce using rule 30 (identifier_list)


State 139

   37 literal_list: literal_list COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 153
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 140

   36 initial_array: L_BRACE literal_list R_BRACE .

    $default  reduce using rule 36 (initial_array)


State 141

   47 compound_statement: $@5 L_BRACE . var_const_stmt_list R_BRACE

    $default  reduce using rule 51 (var_const_stmt_list)

    var_const_stmt_list  go to state 154


State 142

   18 funct_def: VOID ID L_PAREN parameter_list R_PAREN $@4 compound_statement .

    $default  reduce using rule 18 (funct_def)


State 143

   23 parameter_list: parameter_list COMMA scalar_type ID .
   43 array_decl: ID . dim

    ML_BRACE  shift, and go to state 30

    $default  reduce using rule 23 (parameter_list)

    dim  go to state 32


State 144

   24 parameter_list: parameter_list COMMA scalar_type array_decl .

    $default  reduce using rule 24 (parameter_list)


State 145

   41 const_list: const_list COMMA ID ASSIGN_OP literal_const .

    $default  reduce using rule 41 (const_list)


State 146

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN $@2 compound_statement .

    $default  reduce using rule 14 (funct_def)


State 147

  131 factor: SUB_OP L_PAREN logical_expression R_PAREN .

    $default  reduce using rule 131 (factor)


State 148

  135 factor: SUB_OP ID L_PAREN R_PAREN .

    $default  reduce using rule 135 (factor)


State 149

  133 factor: SUB_OP ID L_PAREN logical_expression_list . R_PAREN
  137 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 155
    COMMA    shift, and go to state 151


State 150

  132 factor: ID L_PAREN logical_expression_list R_PAREN .

    $default  reduce using rule 132 (factor)


State 151

  137 logical_expression_list: logical_expression_list COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 156
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 152

  103 dimension: ML_BRACE arithmetic_expression MR_BRACE .

    $default  reduce using rule 103 (dimension)


State 153

   37 literal_list: literal_list COMMA logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 37 (literal_list)


State 154

   47 compound_statement: $@5 L_BRACE var_const_stmt_list . R_BRACE
   48 var_const_stmt_list: var_const_stmt_list . statement
   49                    | var_const_stmt_list . var_decl
   50                    | var_const_stmt_list . const_decl

    READ      shift, and go to state 157
    WHILE     shift, and go to state 158
    IF        shift, and go to state 159
    FOR       shift, and go to state 160
    INT       shift, and go to state 4
    PRINT     shift, and go to state 161
    BOOL      shift, and go to state 5
    FLOAT     shift, and go to state 7
    DOUBLE    shift, and go to state 8
    STRING    shift, and go to state 9
    CONTINUE  shift, and go to state 162
    BREAK     shift, and go to state 163
    RETURN    shift, and go to state 164
    CONST     shift, and go to state 10
    R_BRACE   shift, and go to state 165
    ID        shift, and go to state 166

    DO        reduce using rule 73 ($@13)
    $default  reduce using rule 46 ($@5)

    var_decl                   go to state 167
    const_decl                 go to state 168
    compound_statement         go to state 169
    $@5                        go to state 115
    statement                  go to state 170
    simple_statement           go to state 171
    conditional_statement      go to state 172
    while_statement            go to state 173
    $@13                       go to state 174
    for_statement              go to state 175
    function_invoke_statement  go to state 176
    jump_statement             go to state 177
    variable_reference         go to state 178
    scalar_type                go to state 179


State 155

  133 factor: SUB_OP ID L_PAREN logical_expression_list R_PAREN .

    $default  reduce using rule 133 (factor)


State 156

  104 logical_expression: logical_expression . OR_OP logical_term
  137 logical_expression_list: logical_expression_list COMMA logical_expression .

    OR_OP  shift, and go to state 93

    $default  reduce using rule 137 (logical_expression_list)


State 157

   62 simple_statement: READ . variable_reference SEMICOLON

    ID  shift, and go to state 180

    variable_reference  go to state 181


State 158

   72 while_statement: WHILE . L_PAREN $@10 logical_expression $@11 R_PAREN $@12 compound_statement

    L_PAREN  shift, and go to state 182


State 159

   64 conditional_statement: IF . L_PAREN $@7 conditional_if R_PAREN compound_statement
   67                      | IF . L_PAREN $@8 conditional_if R_PAREN compound_statement $@9 ELSE compound_statement

    L_PAREN  shift, and go to state 183


State 160

   79 for_statement: FOR . L_PAREN initial_expression SEMICOLON $@14 control_expression SEMICOLON $@15 increment_expression $@16 R_PAREN $@17 compound_statement

    L_PAREN  shift, and go to state 184


State 161

   61 simple_statement: PRINT . $@6 logical_expression SEMICOLON

    $default  reduce using rule 60 ($@6)

    $@6  go to state 185


State 162

   98 jump_statement: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 186


State 163

   99 jump_statement: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 187


State 164

  100 jump_statement: RETURN . logical_expression SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 188
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 165

   47 compound_statement: $@5 L_BRACE var_const_stmt_list R_BRACE .

    $default  reduce using rule 47 (compound_statement)


State 166

   96 function_invoke_statement: ID . L_PAREN logical_expression_list R_PAREN SEMICOLON
   97                          | ID . L_PAREN R_PAREN SEMICOLON
  101 variable_reference: ID .

    L_PAREN  shift, and go to state 189

    $default  reduce using rule 101 (variable_reference)


State 167

   49 var_const_stmt_list: var_const_stmt_list var_decl .

    $default  reduce using rule 49 (var_const_stmt_list)


State 168

   50 var_const_stmt_list: var_const_stmt_list const_decl .

    $default  reduce using rule 50 (var_const_stmt_list)


State 169

   52 statement: compound_statement .

    $default  reduce using rule 52 (statement)


State 170

   48 var_const_stmt_list: var_const_stmt_list statement .

    $default  reduce using rule 48 (var_const_stmt_list)


State 171

   53 statement: simple_statement .

    $default  reduce using rule 53 (statement)


State 172

   54 statement: conditional_statement .

    $default  reduce using rule 54 (statement)


State 173

   55 statement: while_statement .

    $default  reduce using rule 55 (statement)


State 174

   74 while_statement: $@13 . DO compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    DO  shift, and go to state 190


State 175

   56 statement: for_statement .

    $default  reduce using rule 56 (statement)


State 176

   57 statement: function_invoke_statement .

    $default  reduce using rule 57 (statement)


State 177

   58 statement: jump_statement .

    $default  reduce using rule 58 (statement)


State 178

   59 simple_statement: variable_reference . ASSIGN_OP logical_expression SEMICOLON
  102 variable_reference: variable_reference . dimension

    ML_BRACE   shift, and go to state 91
    ASSIGN_OP  shift, and go to state 191

    dimension  go to state 92


State 179

   27 var_decl: scalar_type . identifier_list SEMICOLON

    ID  shift, and go to state 192

    identifier_list  go to state 20
    array_decl       go to state 21


State 180

  101 variable_reference: ID .

    $default  reduce using rule 101 (variable_reference)


State 181

   62 simple_statement: READ variable_reference . SEMICOLON
  102 variable_reference: variable_reference . dimension

    SEMICOLON  shift, and go to state 193
    ML_BRACE   shift, and go to state 91

    dimension  go to state 92


State 182

   72 while_statement: WHILE L_PAREN . $@10 logical_expression $@11 R_PAREN $@12 compound_statement

    $default  reduce using rule 69 ($@10)

    $@10  go to state 194


State 183

   64 conditional_statement: IF L_PAREN . $@7 conditional_if R_PAREN compound_statement
   67                      | IF L_PAREN . $@8 conditional_if R_PAREN compound_statement $@9 ELSE compound_statement

    TRUE         reduce using rule 63 ($@7)
    TRUE         [reduce using rule 65 ($@8)]
    FALSE        reduce using rule 63 ($@7)
    FALSE        [reduce using rule 65 ($@8)]
    L_PAREN      reduce using rule 63 ($@7)
    L_PAREN      [reduce using rule 65 ($@8)]
    SUB_OP       reduce using rule 63 ($@7)
    SUB_OP       [reduce using rule 65 ($@8)]
    NOT_OP       reduce using rule 63 ($@7)
    NOT_OP       [reduce using rule 65 ($@8)]
    ID           reduce using rule 63 ($@7)
    ID           [reduce using rule 65 ($@8)]
    INT_CONST    reduce using rule 63 ($@7)
    INT_CONST    [reduce using rule 65 ($@8)]
    FLOAT_CONST  reduce using rule 63 ($@7)
    FLOAT_CONST  [reduce using rule 65 ($@8)]
    SCIENTIFIC   reduce using rule 63 ($@7)
    SCIENTIFIC   [reduce using rule 65 ($@8)]
    STR_CONST    reduce using rule 63 ($@7)
    STR_CONST    [reduce using rule 65 ($@8)]
    $default     reduce using rule 63 ($@7)

    $@7  go to state 195
    $@8  go to state 196


State 184

   79 for_statement: FOR L_PAREN . initial_expression SEMICOLON $@14 control_expression SEMICOLON $@15 increment_expression $@16 R_PAREN $@17 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 84 (initial_expression)

    initial_expression     go to state 197
    statement_for          go to state 198
    variable_reference     go to state 199
    logical_expression     go to state 200
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 185

   61 simple_statement: PRINT $@6 . logical_expression SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 201
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 186

   98 jump_statement: CONTINUE SEMICOLON .

    $default  reduce using rule 98 (jump_statement)


State 187

   99 jump_statement: BREAK SEMICOLON .

    $default  reduce using rule 99 (jump_statement)


State 188

  100 jump_statement: RETURN logical_expression . SEMICOLON
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 93
    SEMICOLON  shift, and go to state 202


State 189

   96 function_invoke_statement: ID L_PAREN . logical_expression_list R_PAREN SEMICOLON
   97                          | ID L_PAREN . R_PAREN SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    R_PAREN      shift, and go to state 203
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference       go to state 55
    logical_expression       go to state 127
    logical_term             go to state 57
    logical_factor           go to state 58
    relation_expression      go to state 59
    arithmetic_expression    go to state 60
    term                     go to state 61
    factor                   go to state 62
    logical_expression_list  go to state 204
    literal_const            go to state 63


State 190

   74 while_statement: $@13 DO . compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 205
    $@5                 go to state 115


State 191

   59 simple_statement: variable_reference ASSIGN_OP . logical_expression SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 206
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 192

   34 identifier_list: ID . ASSIGN_OP logical_expression
   35                | ID .
   43 array_decl: ID . dim

    ML_BRACE   shift, and go to state 30
    ASSIGN_OP  shift, and go to state 31

    $default  reduce using rule 35 (identifier_list)

    dim  go to state 32


State 193

   62 simple_statement: READ variable_reference SEMICOLON .

    $default  reduce using rule 62 (simple_statement)


State 194

   72 while_statement: WHILE L_PAREN $@10 . logical_expression $@11 R_PAREN $@12 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 207
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 195

   64 conditional_statement: IF L_PAREN $@7 . conditional_if R_PAREN compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    conditional_if         go to state 208
    variable_reference     go to state 55
    logical_expression     go to state 209
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 196

   67 conditional_statement: IF L_PAREN $@8 . conditional_if R_PAREN compound_statement $@9 ELSE compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    conditional_if         go to state 210
    variable_reference     go to state 55
    logical_expression     go to state 209
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 197

   79 for_statement: FOR L_PAREN initial_expression . SEMICOLON $@14 control_expression SEMICOLON $@15 increment_expression $@16 R_PAREN $@17 compound_statement
   80 initial_expression: initial_expression . COMMA statement_for
   81                   | initial_expression . COMMA logical_expression

    COMMA      shift, and go to state 211
    SEMICOLON  shift, and go to state 212


State 198

   83 initial_expression: statement_for .

    $default  reduce using rule 83 (initial_expression)


State 199

   95 statement_for: variable_reference . ASSIGN_OP logical_expression
  102 variable_reference: variable_reference . dimension
  128 factor: variable_reference .

    ML_BRACE   shift, and go to state 91
    ASSIGN_OP  shift, and go to state 213

    $default  reduce using rule 128 (factor)

    dimension  go to state 92


State 200

   82 initial_expression: logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 82 (initial_expression)


State 201

   61 simple_statement: PRINT $@6 logical_expression . SEMICOLON
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 93
    SEMICOLON  shift, and go to state 214


State 202

  100 jump_statement: RETURN logical_expression SEMICOLON .

    $default  reduce using rule 100 (jump_statement)


State 203

   97 function_invoke_statement: ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 215


State 204

   96 function_invoke_statement: ID L_PAREN logical_expression_list . R_PAREN SEMICOLON
  137 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 216
    COMMA    shift, and go to state 151


State 205

   74 while_statement: $@13 DO compound_statement . WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    WHILE  shift, and go to state 217


State 206

   59 simple_statement: variable_reference ASSIGN_OP logical_expression . SEMICOLON
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 93
    SEMICOLON  shift, and go to state 218


State 207

   72 while_statement: WHILE L_PAREN $@10 logical_expression . $@11 R_PAREN $@12 compound_statement
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 70 ($@11)

    $@11  go to state 219


State 208

   64 conditional_statement: IF L_PAREN $@7 conditional_if . R_PAREN compound_statement

    R_PAREN  shift, and go to state 220


State 209

   68 conditional_if: logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 68 (conditional_if)


State 210

   67 conditional_statement: IF L_PAREN $@8 conditional_if . R_PAREN compound_statement $@9 ELSE compound_statement

    R_PAREN  shift, and go to state 221


State 211

   80 initial_expression: initial_expression COMMA . statement_for
   81                   | initial_expression COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    statement_for          go to state 222
    variable_reference     go to state 199
    logical_expression     go to state 223
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 212

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON . $@14 control_expression SEMICOLON $@15 increment_expression $@16 R_PAREN $@17 compound_statement

    $default  reduce using rule 75 ($@14)

    $@14  go to state 224


State 213

   95 statement_for: variable_reference ASSIGN_OP . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 225
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 214

   61 simple_statement: PRINT $@6 logical_expression SEMICOLON .

    $default  reduce using rule 61 (simple_statement)


State 215

   97 function_invoke_statement: ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 97 (function_invoke_statement)


State 216

   96 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 226


State 217

   74 while_statement: $@13 DO compound_statement WHILE . L_PAREN logical_expression R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 227


State 218

   59 simple_statement: variable_reference ASSIGN_OP logical_expression SEMICOLON .

    $default  reduce using rule 59 (simple_statement)


State 219

   72 while_statement: WHILE L_PAREN $@10 logical_expression $@11 . R_PAREN $@12 compound_statement

    R_PAREN  shift, and go to state 228


State 220

   64 conditional_statement: IF L_PAREN $@7 conditional_if R_PAREN . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 229
    $@5                 go to state 115


State 221

   67 conditional_statement: IF L_PAREN $@8 conditional_if R_PAREN . compound_statement $@9 ELSE compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 230
    $@5                 go to state 115


State 222

   80 initial_expression: initial_expression COMMA statement_for .

    $default  reduce using rule 80 (initial_expression)


State 223

   81 initial_expression: initial_expression COMMA logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 81 (initial_expression)


State 224

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON $@14 . control_expression SEMICOLON $@15 increment_expression $@16 R_PAREN $@17 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 89 (control_expression)

    control_expression     go to state 231
    statement_for          go to state 232
    variable_reference     go to state 199
    logical_expression     go to state 233
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 225

   95 statement_for: variable_reference ASSIGN_OP logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 95 (statement_for)


State 226

   96 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN SEMICOLON .

    $default  reduce using rule 96 (function_invoke_statement)


State 227

   74 while_statement: $@13 DO compound_statement WHILE L_PAREN . logical_expression R_PAREN SEMICOLON

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    variable_reference     go to state 55
    logical_expression     go to state 234
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 228

   72 while_statement: WHILE L_PAREN $@10 logical_expression $@11 R_PAREN . $@12 compound_statement

    $default  reduce using rule 71 ($@12)

    $@12  go to state 235


State 229

   64 conditional_statement: IF L_PAREN $@7 conditional_if R_PAREN compound_statement .

    $default  reduce using rule 64 (conditional_statement)


State 230

   67 conditional_statement: IF L_PAREN $@8 conditional_if R_PAREN compound_statement . $@9 ELSE compound_statement

    $default  reduce using rule 66 ($@9)

    $@9  go to state 236


State 231

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON $@14 control_expression . SEMICOLON $@15 increment_expression $@16 R_PAREN $@17 compound_statement
   85 control_expression: control_expression . COMMA statement_for
   86                   | control_expression . COMMA logical_expression

    COMMA      shift, and go to state 237
    SEMICOLON  shift, and go to state 238


State 232

   88 control_expression: statement_for .

    $default  reduce using rule 88 (control_expression)


State 233

   87 control_expression: logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 87 (control_expression)


State 234

   74 while_statement: $@13 DO compound_statement WHILE L_PAREN logical_expression . R_PAREN SEMICOLON
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP    shift, and go to state 93
    R_PAREN  shift, and go to state 239


State 235

   72 while_statement: WHILE L_PAREN $@10 logical_expression $@11 R_PAREN $@12 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 240
    $@5                 go to state 115


State 236

   67 conditional_statement: IF L_PAREN $@8 conditional_if R_PAREN compound_statement $@9 . ELSE compound_statement

    ELSE  shift, and go to state 241


State 237

   85 control_expression: control_expression COMMA . statement_for
   86                   | control_expression COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    statement_for          go to state 242
    variable_reference     go to state 199
    logical_expression     go to state 243
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 238

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON $@14 control_expression SEMICOLON . $@15 increment_expression $@16 R_PAREN $@17 compound_statement

    $default  reduce using rule 76 ($@15)

    $@15  go to state 244


State 239

   74 while_statement: $@13 DO compound_statement WHILE L_PAREN logical_expression R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 245


State 240

   72 while_statement: WHILE L_PAREN $@10 logical_expression $@11 R_PAREN $@12 compound_statement .

    $default  reduce using rule 72 (while_statement)


State 241

   67 conditional_statement: IF L_PAREN $@8 conditional_if R_PAREN compound_statement $@9 ELSE . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 246
    $@5                 go to state 115


State 242

   85 control_expression: control_expression COMMA statement_for .

    $default  reduce using rule 85 (control_expression)


State 243

   86 control_expression: control_expression COMMA logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 86 (control_expression)


State 244

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON $@14 control_expression SEMICOLON $@15 . increment_expression $@16 R_PAREN $@17 compound_statement

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    $default  reduce using rule 94 (increment_expression)

    increment_expression   go to state 247
    statement_for          go to state 248
    variable_reference     go to state 199
    logical_expression     go to state 249
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 245

   74 while_statement: $@13 DO compound_statement WHILE L_PAREN logical_expression R_PAREN SEMICOLON .

    $default  reduce using rule 74 (while_statement)


State 246

   67 conditional_statement: IF L_PAREN $@8 conditional_if R_PAREN compound_statement $@9 ELSE compound_statement .

    $default  reduce using rule 67 (conditional_statement)


State 247

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON $@14 control_expression SEMICOLON $@15 increment_expression . $@16 R_PAREN $@17 compound_statement
   90 increment_expression: increment_expression . COMMA statement_for
   91                     | increment_expression . COMMA logical_expression

    COMMA  shift, and go to state 250

    $default  reduce using rule 77 ($@16)

    $@16  go to state 251


State 248

   93 increment_expression: statement_for .

    $default  reduce using rule 93 (increment_expression)


State 249

   92 increment_expression: logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 92 (increment_expression)


State 250

   90 increment_expression: increment_expression COMMA . statement_for
   91                     | increment_expression COMMA . logical_expression

    TRUE         shift, and go to state 45
    FALSE        shift, and go to state 46
    L_PAREN      shift, and go to state 47
    SUB_OP       shift, and go to state 48
    NOT_OP       shift, and go to state 49
    ID           shift, and go to state 50
    INT_CONST    shift, and go to state 51
    FLOAT_CONST  shift, and go to state 52
    SCIENTIFIC   shift, and go to state 53
    STR_CONST    shift, and go to state 54

    statement_for          go to state 252
    variable_reference     go to state 199
    logical_expression     go to state 253
    logical_term           go to state 57
    logical_factor         go to state 58
    relation_expression    go to state 59
    arithmetic_expression  go to state 60
    term                   go to state 61
    factor                 go to state 62
    literal_const          go to state 63


State 251

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON $@14 control_expression SEMICOLON $@15 increment_expression $@16 . R_PAREN $@17 compound_statement

    R_PAREN  shift, and go to state 254


State 252

   90 increment_expression: increment_expression COMMA statement_for .

    $default  reduce using rule 90 (increment_expression)


State 253

   91 increment_expression: increment_expression COMMA logical_expression .
  104 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 93

    $default  reduce using rule 91 (increment_expression)


State 254

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON $@14 control_expression SEMICOLON $@15 increment_expression $@16 R_PAREN . $@17 compound_statement

    $default  reduce using rule 78 ($@17)

    $@17  go to state 255


State 255

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON $@14 control_expression SEMICOLON $@15 increment_expression $@16 R_PAREN $@17 . compound_statement

    $default  reduce using rule 46 ($@5)

    compound_statement  go to state 256
    $@5                 go to state 115


State 256

   79 for_statement: FOR L_PAREN initial_expression SEMICOLON $@14 control_expression SEMICOLON $@15 increment_expression $@16 R_PAREN $@17 compound_statement .

    $default  reduce using rule 79 (for_statement)
