Terminals unused in grammar

   BOOLEAN


Rules useless in parser due to conflicts

   61 $@2: %empty

  112 factor: SUB_OP L_PAREN logical_expression R_PAREN
  116       | SUB_OP ID L_PAREN logical_expression_list R_PAREN
  117       | SUB_OP ID L_PAREN R_PAREN


State 61 conflicts: 7 reduce/reduce
State 62 conflicts: 8 shift/reduce
State 91 conflicts: 18 reduce/reduce
State 92 conflicts: 18 reduce/reduce
State 93 conflicts: 18 reduce/reduce
State 139 conflicts: 8 shift/reduce, 15 reduce/reduce
State 156 conflicts: 18 reduce/reduce
State 158 conflicts: 18 reduce/reduce
State 185 conflicts: 18 reduce/reduce
State 217 conflicts: 1 reduce/reduce


Grammar

    0 $accept: program $end

    1 push_table: %empty

    2 pop_table: %empty

    3 program: push_table decl_list funct_def decl_and_def_list pop_table

    4 decl_list: decl_list var_decl
    5          | decl_list const_decl
    6          | decl_list funct_decl
    7          | %empty

    8 decl_and_def_list: decl_and_def_list var_decl
    9                  | decl_and_def_list const_decl
   10                  | decl_and_def_list funct_decl
   11                  | decl_and_def_list funct_def
   12                  | %empty

   13 funct_def: scalar_type ID L_PAREN R_PAREN compound_statement
   14          | scalar_type ID L_PAREN parameter_list R_PAREN compound_statement
   15          | VOID ID L_PAREN R_PAREN compound_statement
   16          | VOID ID L_PAREN parameter_list R_PAREN compound_statement

   17 funct_decl: scalar_type ID L_PAREN R_PAREN SEMICOLON
   18           | scalar_type ID L_PAREN parameter_list R_PAREN SEMICOLON
   19           | VOID ID L_PAREN R_PAREN SEMICOLON
   20           | VOID ID L_PAREN parameter_list R_PAREN SEMICOLON

   21 parameter_list: parameter_list COMMA scalar_type ID
   22               | parameter_list COMMA scalar_type array_decl
   23               | scalar_type array_decl
   24               | scalar_type ID

   25 var_decl: scalar_type identifier_list SEMICOLON

   26 identifier_list: identifier_list COMMA ID
   27                | identifier_list COMMA ID ASSIGN_OP logical_expression
   28                | identifier_list COMMA array_decl ASSIGN_OP initial_array
   29                | identifier_list COMMA array_decl
   30                | array_decl ASSIGN_OP initial_array
   31                | array_decl
   32                | ID ASSIGN_OP logical_expression
   33                | ID

   34 initial_array: L_BRACE literal_list R_BRACE

   35 literal_list: literal_list COMMA logical_expression
   36             | logical_expression
   37             | %empty

   38 const_decl: CONST scalar_type const_list SEMICOLON

   39 const_list: const_list COMMA ID ASSIGN_OP literal_const
   40           | ID ASSIGN_OP literal_const

   41 array_decl: ID dim

   42 dim: dim ML_BRACE INT_CONST MR_BRACE
   43    | ML_BRACE INT_CONST MR_BRACE

   44 compound_statement: push_table L_BRACE var_const_stmt_list R_BRACE pop_table

   45 var_const_stmt_list: var_const_stmt_list statement
   46                    | var_const_stmt_list var_decl
   47                    | var_const_stmt_list const_decl
   48                    | %empty

   49 statement: compound_statement
   50          | simple_statement
   51          | conditional_statement
   52          | while_statement
   53          | for_statement
   54          | function_invoke_statement
   55          | jump_statement

   56 simple_statement: variable_reference ASSIGN_OP logical_expression SEMICOLON
   57                 | PRINT logical_expression SEMICOLON
   58                 | READ variable_reference SEMICOLON

   59 $@1: %empty

   60 conditional_statement: IF L_PAREN logical_expression R_PAREN $@1 push_table L_BRACE var_const_stmt_list R_BRACE pop_table

   61 $@2: %empty

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table

   63 $@3: %empty

   64 while_statement: WHILE L_PAREN logical_expression R_PAREN $@3 push_table L_BRACE var_const_stmt_list R_BRACE pop_table
   65                | DO push_table L_BRACE var_const_stmt_list R_BRACE pop_table WHILE L_PAREN logical_expression R_PAREN SEMICOLON

   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON control_expression SEMICOLON increment_expression_list R_PAREN push_table L_BRACE var_const_stmt_list R_BRACE pop_table

   67 initial_expression_list: initial_expression
   68                        | %empty

   69 initial_expression: initial_expression COMMA variable_reference ASSIGN_OP logical_expression
   70                   | initial_expression COMMA logical_expression
   71                   | logical_expression
   72                   | variable_reference ASSIGN_OP logical_expression

   73 control_expression: logical_expression

   74 increment_expression_list: increment_expression
   75                          | %empty

   76 increment_expression: increment_expression COMMA variable_reference ASSIGN_OP logical_expression
   77                     | increment_expression COMMA logical_expression
   78                     | logical_expression
   79                     | variable_reference ASSIGN_OP logical_expression

   80 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN SEMICOLON
   81                          | ID L_PAREN R_PAREN SEMICOLON

   82 jump_statement: CONTINUE SEMICOLON
   83               | BREAK SEMICOLON
   84               | RETURN logical_expression SEMICOLON

   85 variable_reference: array_list
   86                   | ID

   87 logical_expression: logical_expression OR_OP logical_term
   88                   | logical_term

   89 logical_term: logical_term AND_OP logical_factor
   90             | logical_factor

   91 logical_factor: NOT_OP logical_factor
   92               | relation_expression

   93 relation_expression: arithmetic_expression relation_operator arithmetic_expression
   94                    | arithmetic_expression

   95 relation_operator: LT_OP
   96                  | LE_OP
   97                  | EQ_OP
   98                  | GE_OP
   99                  | GT_OP
  100                  | NE_OP

  101 arithmetic_expression: arithmetic_expression ADD_OP term
  102                      | arithmetic_expression SUB_OP term
  103                      | relation_expression
  104                      | term

  105 term: term MUL_OP factor
  106     | term DIV_OP factor
  107     | term MOD_OP factor
  108     | factor

  109 factor: variable_reference
  110       | SUB_OP factor
  111       | L_PAREN logical_expression R_PAREN
  112       | SUB_OP L_PAREN logical_expression R_PAREN
  113       | ID L_PAREN logical_expression_list R_PAREN
  114       | ID L_PAREN R_PAREN
  115       | literal_const
  116       | SUB_OP ID L_PAREN logical_expression_list R_PAREN
  117       | SUB_OP ID L_PAREN R_PAREN

  118 logical_expression_list: logical_expression_list COMMA logical_expression
  119                        | logical_expression

  120 array_list: ID dimension

  121 dimension: dimension ML_BRACE logical_expression MR_BRACE
  122          | ML_BRACE logical_expression MR_BRACE

  123 scalar_type: INT
  124            | DOUBLE
  125            | STRING
  126            | BOOL
  127            | FLOAT

  128 literal_const: INT_CONST
  129              | SUB_OP INT_CONST
  130              | FLOAT_CONST
  131              | SUB_OP FLOAT_CONST
  132              | SCIENTIFIC
  133              | SUB_OP SCIENTIFIC
  134              | STR_CONST
  135              | TRUE
  136              | FALSE


Terminals, with rules where they appear

$end (0) 0
error (256)
ID (258) 13 14 15 16 17 18 19 20 21 24 26 27 32 33 39 40 41 80 81 86
    113 114 116 117 120
INT_CONST (259) 42 43 128 129
FLOAT_CONST (260) 130 131
SCIENTIFIC (261) 132 133
STR_CONST (262) 134
LE_OP (263) 96
NE_OP (264) 100
GE_OP (265) 98
EQ_OP (266) 97
AND_OP (267) 89
OR_OP (268) 87
READ (269) 58
BOOLEAN (270)
WHILE (271) 64 65
DO (272) 65
IF (273) 60 62
ELSE (274) 62
TRUE (275) 135
FALSE (276) 136
FOR (277) 66
INT (278) 123
PRINT (279) 57
BOOL (280) 126
VOID (281) 15 16 19 20
FLOAT (282) 127
DOUBLE (283) 124
STRING (284) 125
CONTINUE (285) 82
BREAK (286) 83
RETURN (287) 84
CONST (288) 38
L_PAREN (289) 13 14 15 16 17 18 19 20 60 62 64 65 66 80 81 111 112
    113 114 116 117
R_PAREN (290) 13 14 15 16 17 18 19 20 60 62 64 65 66 80 81 111 112
    113 114 116 117
COMMA (291) 21 22 26 27 28 29 35 39 69 70 76 77 118
SEMICOLON (292) 17 18 19 20 25 38 56 57 58 65 66 80 81 82 83 84
ML_BRACE (293) 42 43 121 122
MR_BRACE (294) 42 43 121 122
L_BRACE (295) 34 44 60 62 64 65 66
R_BRACE (296) 34 44 60 62 64 65 66
ADD_OP (297) 101
SUB_OP (298) 102 110 112 116 117 129 131 133
MUL_OP (299) 105
DIV_OP (300) 106
MOD_OP (301) 107
ASSIGN_OP (302) 27 28 30 32 39 40 56 69 72 76 79
LT_OP (303) 95
GT_OP (304) 99
NOT_OP (305) 91


Nonterminals, with rules where they appear

$accept (51)
    on left: 0
push_table (52)
    on left: 1, on right: 3 44 60 62 64 65 66
pop_table (53)
    on left: 2, on right: 3 44 60 62 64 65 66
program (54)
    on left: 3, on right: 0
decl_list (55)
    on left: 4 5 6 7, on right: 3 4 5 6
decl_and_def_list (56)
    on left: 8 9 10 11 12, on right: 3 8 9 10 11
funct_def (57)
    on left: 13 14 15 16, on right: 3 11
funct_decl (58)
    on left: 17 18 19 20, on right: 6 10
parameter_list (59)
    on left: 21 22 23 24, on right: 14 16 18 20 21 22
var_decl (60)
    on left: 25, on right: 4 8 46
identifier_list (61)
    on left: 26 27 28 29 30 31 32 33, on right: 25 26 27 28 29
initial_array (62)
    on left: 34, on right: 28 30
literal_list (63)
    on left: 35 36 37, on right: 34 35
const_decl (64)
    on left: 38, on right: 5 9 47
const_list (65)
    on left: 39 40, on right: 38 39
array_decl (66)
    on left: 41, on right: 22 23 28 29 30 31
dim (67)
    on left: 42 43, on right: 41 42
compound_statement (68)
    on left: 44, on right: 13 14 15 16 49
var_const_stmt_list (69)
    on left: 45 46 47 48, on right: 44 45 46 47 60 62 64 65 66
statement (70)
    on left: 49 50 51 52 53 54 55, on right: 45
simple_statement (71)
    on left: 56 57 58, on right: 50
conditional_statement (72)
    on left: 60 62, on right: 51
$@1 (73)
    on left: 59, on right: 60
$@2 (74)
    on left: 61, on right: 62
while_statement (75)
    on left: 64 65, on right: 52
$@3 (76)
    on left: 63, on right: 64
for_statement (77)
    on left: 66, on right: 53
initial_expression_list (78)
    on left: 67 68, on right: 66
initial_expression (79)
    on left: 69 70 71 72, on right: 67 69 70
control_expression (80)
    on left: 73, on right: 66
increment_expression_list (81)
    on left: 74 75, on right: 66
increment_expression (82)
    on left: 76 77 78 79, on right: 74 76 77
function_invoke_statement (83)
    on left: 80 81, on right: 54
jump_statement (84)
    on left: 82 83 84, on right: 55
variable_reference (85)
    on left: 85 86, on right: 56 58 69 72 76 79 109
logical_expression (86)
    on left: 87 88, on right: 27 32 35 36 56 57 60 62 64 65 69 70 71
    72 73 76 77 78 79 84 87 111 112 118 119 121 122
logical_term (87)
    on left: 89 90, on right: 87 88 89
logical_factor (88)
    on left: 91 92, on right: 89 90 91
relation_expression (89)
    on left: 93 94, on right: 92 103
relation_operator (90)
    on left: 95 96 97 98 99 100, on right: 93
arithmetic_expression (91)
    on left: 101 102 103 104, on right: 93 94 101 102
term (92)
    on left: 105 106 107 108, on right: 101 102 104 105 106 107
factor (93)
    on left: 109 110 111 112 113 114 115 116 117, on right: 105 106
    107 108 110
logical_expression_list (94)
    on left: 118 119, on right: 80 113 116 118
array_list (95)
    on left: 120, on right: 85
dimension (96)
    on left: 121 122, on right: 120 121
scalar_type (97)
    on left: 123 124 125 126 127, on right: 13 14 17 18 21 22 23 24
    25 38
literal_const (98)
    on left: 128 129 130 131 132 133 134 135 136, on right: 39 40 115


State 0

    0 $accept: . program $end

    $default  reduce using rule 1 (push_table)

    push_table  go to state 1
    program     go to state 2


State 1

    3 program: push_table . decl_list funct_def decl_and_def_list pop_table

    $default  reduce using rule 7 (decl_list)

    decl_list  go to state 3


State 2

    0 $accept: program . $end

    $end  shift, and go to state 4


State 3

    3 program: push_table decl_list . funct_def decl_and_def_list pop_table
    4 decl_list: decl_list . var_decl
    5          | decl_list . const_decl
    6          | decl_list . funct_decl

    INT     shift, and go to state 5
    BOOL    shift, and go to state 6
    VOID    shift, and go to state 7
    FLOAT   shift, and go to state 8
    DOUBLE  shift, and go to state 9
    STRING  shift, and go to state 10
    CONST   shift, and go to state 11

    funct_def    go to state 12
    funct_decl   go to state 13
    var_decl     go to state 14
    const_decl   go to state 15
    scalar_type  go to state 16


State 4

    0 $accept: program $end .

    $default  accept


State 5

  123 scalar_type: INT .

    $default  reduce using rule 123 (scalar_type)


State 6

  126 scalar_type: BOOL .

    $default  reduce using rule 126 (scalar_type)


State 7

   15 funct_def: VOID . ID L_PAREN R_PAREN compound_statement
   16          | VOID . ID L_PAREN parameter_list R_PAREN compound_statement
   19 funct_decl: VOID . ID L_PAREN R_PAREN SEMICOLON
   20           | VOID . ID L_PAREN parameter_list R_PAREN SEMICOLON

    ID  shift, and go to state 17


State 8

  127 scalar_type: FLOAT .

    $default  reduce using rule 127 (scalar_type)


State 9

  124 scalar_type: DOUBLE .

    $default  reduce using rule 124 (scalar_type)


State 10

  125 scalar_type: STRING .

    $default  reduce using rule 125 (scalar_type)


State 11

   38 const_decl: CONST . scalar_type const_list SEMICOLON

    INT     shift, and go to state 5
    BOOL    shift, and go to state 6
    FLOAT   shift, and go to state 8
    DOUBLE  shift, and go to state 9
    STRING  shift, and go to state 10

    scalar_type  go to state 18


State 12

    3 program: push_table decl_list funct_def . decl_and_def_list pop_table

    $default  reduce using rule 12 (decl_and_def_list)

    decl_and_def_list  go to state 19


State 13

    6 decl_list: decl_list funct_decl .

    $default  reduce using rule 6 (decl_list)


State 14

    4 decl_list: decl_list var_decl .

    $default  reduce using rule 4 (decl_list)


State 15

    5 decl_list: decl_list const_decl .

    $default  reduce using rule 5 (decl_list)


State 16

   13 funct_def: scalar_type . ID L_PAREN R_PAREN compound_statement
   14          | scalar_type . ID L_PAREN parameter_list R_PAREN compound_statement
   17 funct_decl: scalar_type . ID L_PAREN R_PAREN SEMICOLON
   18           | scalar_type . ID L_PAREN parameter_list R_PAREN SEMICOLON
   25 var_decl: scalar_type . identifier_list SEMICOLON

    ID  shift, and go to state 20

    identifier_list  go to state 21
    array_decl       go to state 22


State 17

   15 funct_def: VOID ID . L_PAREN R_PAREN compound_statement
   16          | VOID ID . L_PAREN parameter_list R_PAREN compound_statement
   19 funct_decl: VOID ID . L_PAREN R_PAREN SEMICOLON
   20           | VOID ID . L_PAREN parameter_list R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 23


State 18

   38 const_decl: CONST scalar_type . const_list SEMICOLON

    ID  shift, and go to state 24

    const_list  go to state 25


State 19

    3 program: push_table decl_list funct_def decl_and_def_list . pop_table
    8 decl_and_def_list: decl_and_def_list . var_decl
    9                  | decl_and_def_list . const_decl
   10                  | decl_and_def_list . funct_decl
   11                  | decl_and_def_list . funct_def

    INT     shift, and go to state 5
    BOOL    shift, and go to state 6
    VOID    shift, and go to state 7
    FLOAT   shift, and go to state 8
    DOUBLE  shift, and go to state 9
    STRING  shift, and go to state 10
    CONST   shift, and go to state 11

    $default  reduce using rule 2 (pop_table)

    pop_table    go to state 26
    funct_def    go to state 27
    funct_decl   go to state 28
    var_decl     go to state 29
    const_decl   go to state 30
    scalar_type  go to state 16


State 20

   13 funct_def: scalar_type ID . L_PAREN R_PAREN compound_statement
   14          | scalar_type ID . L_PAREN parameter_list R_PAREN compound_statement
   17 funct_decl: scalar_type ID . L_PAREN R_PAREN SEMICOLON
   18           | scalar_type ID . L_PAREN parameter_list R_PAREN SEMICOLON
   32 identifier_list: ID . ASSIGN_OP logical_expression
   33                | ID .
   41 array_decl: ID . dim

    L_PAREN    shift, and go to state 31
    ML_BRACE   shift, and go to state 32
    ASSIGN_OP  shift, and go to state 33

    $default  reduce using rule 33 (identifier_list)

    dim  go to state 34


State 21

   25 var_decl: scalar_type identifier_list . SEMICOLON
   26 identifier_list: identifier_list . COMMA ID
   27                | identifier_list . COMMA ID ASSIGN_OP logical_expression
   28                | identifier_list . COMMA array_decl ASSIGN_OP initial_array
   29                | identifier_list . COMMA array_decl

    COMMA      shift, and go to state 35
    SEMICOLON  shift, and go to state 36


State 22

   30 identifier_list: array_decl . ASSIGN_OP initial_array
   31                | array_decl .

    ASSIGN_OP  shift, and go to state 37

    $default  reduce using rule 31 (identifier_list)


State 23

   15 funct_def: VOID ID L_PAREN . R_PAREN compound_statement
   16          | VOID ID L_PAREN . parameter_list R_PAREN compound_statement
   19 funct_decl: VOID ID L_PAREN . R_PAREN SEMICOLON
   20           | VOID ID L_PAREN . parameter_list R_PAREN SEMICOLON

    INT      shift, and go to state 5
    BOOL     shift, and go to state 6
    FLOAT    shift, and go to state 8
    DOUBLE   shift, and go to state 9
    STRING   shift, and go to state 10
    R_PAREN  shift, and go to state 38

    parameter_list  go to state 39
    scalar_type     go to state 40


State 24

   40 const_list: ID . ASSIGN_OP literal_const

    ASSIGN_OP  shift, and go to state 41


State 25

   38 const_decl: CONST scalar_type const_list . SEMICOLON
   39 const_list: const_list . COMMA ID ASSIGN_OP literal_const

    COMMA      shift, and go to state 42
    SEMICOLON  shift, and go to state 43


State 26

    3 program: push_table decl_list funct_def decl_and_def_list pop_table .

    $default  reduce using rule 3 (program)


State 27

   11 decl_and_def_list: decl_and_def_list funct_def .

    $default  reduce using rule 11 (decl_and_def_list)


State 28

   10 decl_and_def_list: decl_and_def_list funct_decl .

    $default  reduce using rule 10 (decl_and_def_list)


State 29

    8 decl_and_def_list: decl_and_def_list var_decl .

    $default  reduce using rule 8 (decl_and_def_list)


State 30

    9 decl_and_def_list: decl_and_def_list const_decl .

    $default  reduce using rule 9 (decl_and_def_list)


State 31

   13 funct_def: scalar_type ID L_PAREN . R_PAREN compound_statement
   14          | scalar_type ID L_PAREN . parameter_list R_PAREN compound_statement
   17 funct_decl: scalar_type ID L_PAREN . R_PAREN SEMICOLON
   18           | scalar_type ID L_PAREN . parameter_list R_PAREN SEMICOLON

    INT      shift, and go to state 5
    BOOL     shift, and go to state 6
    FLOAT    shift, and go to state 8
    DOUBLE   shift, and go to state 9
    STRING   shift, and go to state 10
    R_PAREN  shift, and go to state 44

    parameter_list  go to state 45
    scalar_type     go to state 40


State 32

   43 dim: ML_BRACE . INT_CONST MR_BRACE

    INT_CONST  shift, and go to state 46


State 33

   32 identifier_list: ID ASSIGN_OP . logical_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 58
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 34

   41 array_decl: ID dim .
   42 dim: dim . ML_BRACE INT_CONST MR_BRACE

    ML_BRACE  shift, and go to state 67

    $default  reduce using rule 41 (array_decl)


State 35

   26 identifier_list: identifier_list COMMA . ID
   27                | identifier_list COMMA . ID ASSIGN_OP logical_expression
   28                | identifier_list COMMA . array_decl ASSIGN_OP initial_array
   29                | identifier_list COMMA . array_decl

    ID  shift, and go to state 68

    array_decl  go to state 69


State 36

   25 var_decl: scalar_type identifier_list SEMICOLON .

    $default  reduce using rule 25 (var_decl)


State 37

   30 identifier_list: array_decl ASSIGN_OP . initial_array

    L_BRACE  shift, and go to state 70

    initial_array  go to state 71


State 38

   15 funct_def: VOID ID L_PAREN R_PAREN . compound_statement
   19 funct_decl: VOID ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 72

    $default  reduce using rule 1 (push_table)

    push_table          go to state 73
    compound_statement  go to state 74


State 39

   16 funct_def: VOID ID L_PAREN parameter_list . R_PAREN compound_statement
   20 funct_decl: VOID ID L_PAREN parameter_list . R_PAREN SEMICOLON
   21 parameter_list: parameter_list . COMMA scalar_type ID
   22               | parameter_list . COMMA scalar_type array_decl

    R_PAREN  shift, and go to state 75
    COMMA    shift, and go to state 76


State 40

   23 parameter_list: scalar_type . array_decl
   24               | scalar_type . ID

    ID  shift, and go to state 77

    array_decl  go to state 78


State 41

   40 const_list: ID ASSIGN_OP . literal_const

    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    SUB_OP       shift, and go to state 79

    literal_const  go to state 80


State 42

   39 const_list: const_list COMMA . ID ASSIGN_OP literal_const

    ID  shift, and go to state 81


State 43

   38 const_decl: CONST scalar_type const_list SEMICOLON .

    $default  reduce using rule 38 (const_decl)


State 44

   13 funct_def: scalar_type ID L_PAREN R_PAREN . compound_statement
   17 funct_decl: scalar_type ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 82

    $default  reduce using rule 1 (push_table)

    push_table          go to state 73
    compound_statement  go to state 83


State 45

   14 funct_def: scalar_type ID L_PAREN parameter_list . R_PAREN compound_statement
   18 funct_decl: scalar_type ID L_PAREN parameter_list . R_PAREN SEMICOLON
   21 parameter_list: parameter_list . COMMA scalar_type ID
   22               | parameter_list . COMMA scalar_type array_decl

    R_PAREN  shift, and go to state 84
    COMMA    shift, and go to state 76


State 46

   43 dim: ML_BRACE INT_CONST . MR_BRACE

    MR_BRACE  shift, and go to state 85


State 47

   86 variable_reference: ID .
  113 factor: ID . L_PAREN logical_expression_list R_PAREN
  114       | ID . L_PAREN R_PAREN
  120 array_list: ID . dimension

    L_PAREN   shift, and go to state 86
    ML_BRACE  shift, and go to state 87

    $default  reduce using rule 86 (variable_reference)

    dimension  go to state 88


State 48

  128 literal_const: INT_CONST .

    $default  reduce using rule 128 (literal_const)


State 49

  130 literal_const: FLOAT_CONST .

    $default  reduce using rule 130 (literal_const)


State 50

  132 literal_const: SCIENTIFIC .

    $default  reduce using rule 132 (literal_const)


State 51

  134 literal_const: STR_CONST .

    $default  reduce using rule 134 (literal_const)


State 52

  135 literal_const: TRUE .

    $default  reduce using rule 135 (literal_const)


State 53

  136 literal_const: FALSE .

    $default  reduce using rule 136 (literal_const)


State 54

  111 factor: L_PAREN . logical_expression R_PAREN

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 89
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 55

  110 factor: SUB_OP . factor
  112       | SUB_OP . L_PAREN logical_expression R_PAREN
  116       | SUB_OP . ID L_PAREN logical_expression_list R_PAREN
  117       | SUB_OP . ID L_PAREN R_PAREN
  129 literal_const: SUB_OP . INT_CONST
  131              | SUB_OP . FLOAT_CONST
  133              | SUB_OP . SCIENTIFIC

    ID           shift, and go to state 90
    INT_CONST    shift, and go to state 91
    FLOAT_CONST  shift, and go to state 92
    SCIENTIFIC   shift, and go to state 93
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 94
    SUB_OP       shift, and go to state 55

    variable_reference  go to state 57
    factor              go to state 95
    array_list          go to state 65
    literal_const       go to state 66


State 56

   91 logical_factor: NOT_OP . logical_factor

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_factor         go to state 96
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 57

  109 factor: variable_reference .

    $default  reduce using rule 109 (factor)


State 58

   32 identifier_list: ID ASSIGN_OP logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 32 (identifier_list)


State 59

   88 logical_expression: logical_term .
   89 logical_term: logical_term . AND_OP logical_factor

    AND_OP  shift, and go to state 98

    $default  reduce using rule 88 (logical_expression)


State 60

   90 logical_term: logical_factor .

    $default  reduce using rule 90 (logical_term)


State 61

   92 logical_factor: relation_expression .
  103 arithmetic_expression: relation_expression .

    AND_OP     reduce using rule 92 (logical_factor)
    AND_OP     [reduce using rule 103 (arithmetic_expression)]
    OR_OP      reduce using rule 92 (logical_factor)
    OR_OP      [reduce using rule 103 (arithmetic_expression)]
    R_PAREN    reduce using rule 92 (logical_factor)
    R_PAREN    [reduce using rule 103 (arithmetic_expression)]
    COMMA      reduce using rule 92 (logical_factor)
    COMMA      [reduce using rule 103 (arithmetic_expression)]
    SEMICOLON  reduce using rule 92 (logical_factor)
    SEMICOLON  [reduce using rule 103 (arithmetic_expression)]
    MR_BRACE   reduce using rule 92 (logical_factor)
    MR_BRACE   [reduce using rule 103 (arithmetic_expression)]
    R_BRACE    reduce using rule 92 (logical_factor)
    R_BRACE    [reduce using rule 103 (arithmetic_expression)]
    $default   reduce using rule 103 (arithmetic_expression)


State 62

   93 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
   94                    | arithmetic_expression .
  101 arithmetic_expression: arithmetic_expression . ADD_OP term
  102                      | arithmetic_expression . SUB_OP term

    LE_OP   shift, and go to state 99
    NE_OP   shift, and go to state 100
    GE_OP   shift, and go to state 101
    EQ_OP   shift, and go to state 102
    ADD_OP  shift, and go to state 103
    SUB_OP  shift, and go to state 104
    LT_OP   shift, and go to state 105
    GT_OP   shift, and go to state 106

    LE_OP     [reduce using rule 94 (relation_expression)]
    NE_OP     [reduce using rule 94 (relation_expression)]
    GE_OP     [reduce using rule 94 (relation_expression)]
    EQ_OP     [reduce using rule 94 (relation_expression)]
    ADD_OP    [reduce using rule 94 (relation_expression)]
    SUB_OP    [reduce using rule 94 (relation_expression)]
    LT_OP     [reduce using rule 94 (relation_expression)]
    GT_OP     [reduce using rule 94 (relation_expression)]
    $default  reduce using rule 94 (relation_expression)

    relation_operator  go to state 107


State 63

  104 arithmetic_expression: term .
  105 term: term . MUL_OP factor
  106     | term . DIV_OP factor
  107     | term . MOD_OP factor

    MUL_OP  shift, and go to state 108
    DIV_OP  shift, and go to state 109
    MOD_OP  shift, and go to state 110

    $default  reduce using rule 104 (arithmetic_expression)


State 64

  108 term: factor .

    $default  reduce using rule 108 (term)


State 65

   85 variable_reference: array_list .

    $default  reduce using rule 85 (variable_reference)


State 66

  115 factor: literal_const .

    $default  reduce using rule 115 (factor)


State 67

   42 dim: dim ML_BRACE . INT_CONST MR_BRACE

    INT_CONST  shift, and go to state 111


State 68

   26 identifier_list: identifier_list COMMA ID .
   27                | identifier_list COMMA ID . ASSIGN_OP logical_expression
   41 array_decl: ID . dim

    ML_BRACE   shift, and go to state 32
    ASSIGN_OP  shift, and go to state 112

    $default  reduce using rule 26 (identifier_list)

    dim  go to state 34


State 69

   28 identifier_list: identifier_list COMMA array_decl . ASSIGN_OP initial_array
   29                | identifier_list COMMA array_decl .

    ASSIGN_OP  shift, and go to state 113

    $default  reduce using rule 29 (identifier_list)


State 70

   34 initial_array: L_BRACE . literal_list R_BRACE

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    $default  reduce using rule 37 (literal_list)

    literal_list           go to state 114
    variable_reference     go to state 57
    logical_expression     go to state 115
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 71

   30 identifier_list: array_decl ASSIGN_OP initial_array .

    $default  reduce using rule 30 (identifier_list)


State 72

   19 funct_decl: VOID ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 19 (funct_decl)


State 73

   44 compound_statement: push_table . L_BRACE var_const_stmt_list R_BRACE pop_table

    L_BRACE  shift, and go to state 116


State 74

   15 funct_def: VOID ID L_PAREN R_PAREN compound_statement .

    $default  reduce using rule 15 (funct_def)


State 75

   16 funct_def: VOID ID L_PAREN parameter_list R_PAREN . compound_statement
   20 funct_decl: VOID ID L_PAREN parameter_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 117

    $default  reduce using rule 1 (push_table)

    push_table          go to state 73
    compound_statement  go to state 118


State 76

   21 parameter_list: parameter_list COMMA . scalar_type ID
   22               | parameter_list COMMA . scalar_type array_decl

    INT     shift, and go to state 5
    BOOL    shift, and go to state 6
    FLOAT   shift, and go to state 8
    DOUBLE  shift, and go to state 9
    STRING  shift, and go to state 10

    scalar_type  go to state 119


State 77

   24 parameter_list: scalar_type ID .
   41 array_decl: ID . dim

    ML_BRACE  shift, and go to state 32

    $default  reduce using rule 24 (parameter_list)

    dim  go to state 34


State 78

   23 parameter_list: scalar_type array_decl .

    $default  reduce using rule 23 (parameter_list)


State 79

  129 literal_const: SUB_OP . INT_CONST
  131              | SUB_OP . FLOAT_CONST
  133              | SUB_OP . SCIENTIFIC

    INT_CONST    shift, and go to state 120
    FLOAT_CONST  shift, and go to state 121
    SCIENTIFIC   shift, and go to state 122


State 80

   40 const_list: ID ASSIGN_OP literal_const .

    $default  reduce using rule 40 (const_list)


State 81

   39 const_list: const_list COMMA ID . ASSIGN_OP literal_const

    ASSIGN_OP  shift, and go to state 123


State 82

   17 funct_decl: scalar_type ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 17 (funct_decl)


State 83

   13 funct_def: scalar_type ID L_PAREN R_PAREN compound_statement .

    $default  reduce using rule 13 (funct_def)


State 84

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN . compound_statement
   18 funct_decl: scalar_type ID L_PAREN parameter_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 124

    $default  reduce using rule 1 (push_table)

    push_table          go to state 73
    compound_statement  go to state 125


State 85

   43 dim: ML_BRACE INT_CONST MR_BRACE .

    $default  reduce using rule 43 (dim)


State 86

  113 factor: ID L_PAREN . logical_expression_list R_PAREN
  114       | ID L_PAREN . R_PAREN

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    R_PAREN      shift, and go to state 126
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference       go to state 57
    logical_expression       go to state 127
    logical_term             go to state 59
    logical_factor           go to state 60
    relation_expression      go to state 61
    arithmetic_expression    go to state 62
    term                     go to state 63
    factor                   go to state 64
    logical_expression_list  go to state 128
    array_list               go to state 65
    literal_const            go to state 66


State 87

  122 dimension: ML_BRACE . logical_expression MR_BRACE

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 129
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 88

  120 array_list: ID dimension .
  121 dimension: dimension . ML_BRACE logical_expression MR_BRACE

    ML_BRACE  shift, and go to state 130

    $default  reduce using rule 120 (array_list)


State 89

   87 logical_expression: logical_expression . OR_OP logical_term
  111 factor: L_PAREN logical_expression . R_PAREN

    OR_OP    shift, and go to state 97
    R_PAREN  shift, and go to state 131


State 90

   86 variable_reference: ID .
  113 factor: ID . L_PAREN logical_expression_list R_PAREN
  114       | ID . L_PAREN R_PAREN
  116       | SUB_OP ID . L_PAREN logical_expression_list R_PAREN
  117       | SUB_OP ID . L_PAREN R_PAREN
  120 array_list: ID . dimension

    L_PAREN   shift, and go to state 132
    ML_BRACE  shift, and go to state 87

    $default  reduce using rule 86 (variable_reference)

    dimension  go to state 88


State 91

  128 literal_const: INT_CONST .
  129              | SUB_OP INT_CONST .

    LE_OP      reduce using rule 128 (literal_const)
    LE_OP      [reduce using rule 129 (literal_const)]
    NE_OP      reduce using rule 128 (literal_const)
    NE_OP      [reduce using rule 129 (literal_const)]
    GE_OP      reduce using rule 128 (literal_const)
    GE_OP      [reduce using rule 129 (literal_const)]
    EQ_OP      reduce using rule 128 (literal_const)
    EQ_OP      [reduce using rule 129 (literal_const)]
    AND_OP     reduce using rule 128 (literal_const)
    AND_OP     [reduce using rule 129 (literal_const)]
    OR_OP      reduce using rule 128 (literal_const)
    OR_OP      [reduce using rule 129 (literal_const)]
    R_PAREN    reduce using rule 128 (literal_const)
    R_PAREN    [reduce using rule 129 (literal_const)]
    COMMA      reduce using rule 128 (literal_const)
    COMMA      [reduce using rule 129 (literal_const)]
    SEMICOLON  reduce using rule 128 (literal_const)
    SEMICOLON  [reduce using rule 129 (literal_const)]
    MR_BRACE   reduce using rule 128 (literal_const)
    MR_BRACE   [reduce using rule 129 (literal_const)]
    R_BRACE    reduce using rule 128 (literal_const)
    R_BRACE    [reduce using rule 129 (literal_const)]
    ADD_OP     reduce using rule 128 (literal_const)
    ADD_OP     [reduce using rule 129 (literal_const)]
    SUB_OP     reduce using rule 128 (literal_const)
    SUB_OP     [reduce using rule 129 (literal_const)]
    MUL_OP     reduce using rule 128 (literal_const)
    MUL_OP     [reduce using rule 129 (literal_const)]
    DIV_OP     reduce using rule 128 (literal_const)
    DIV_OP     [reduce using rule 129 (literal_const)]
    MOD_OP     reduce using rule 128 (literal_const)
    MOD_OP     [reduce using rule 129 (literal_const)]
    LT_OP      reduce using rule 128 (literal_const)
    LT_OP      [reduce using rule 129 (literal_const)]
    GT_OP      reduce using rule 128 (literal_const)
    GT_OP      [reduce using rule 129 (literal_const)]
    $default   reduce using rule 128 (literal_const)


State 92

  130 literal_const: FLOAT_CONST .
  131              | SUB_OP FLOAT_CONST .

    LE_OP      reduce using rule 130 (literal_const)
    LE_OP      [reduce using rule 131 (literal_const)]
    NE_OP      reduce using rule 130 (literal_const)
    NE_OP      [reduce using rule 131 (literal_const)]
    GE_OP      reduce using rule 130 (literal_const)
    GE_OP      [reduce using rule 131 (literal_const)]
    EQ_OP      reduce using rule 130 (literal_const)
    EQ_OP      [reduce using rule 131 (literal_const)]
    AND_OP     reduce using rule 130 (literal_const)
    AND_OP     [reduce using rule 131 (literal_const)]
    OR_OP      reduce using rule 130 (literal_const)
    OR_OP      [reduce using rule 131 (literal_const)]
    R_PAREN    reduce using rule 130 (literal_const)
    R_PAREN    [reduce using rule 131 (literal_const)]
    COMMA      reduce using rule 130 (literal_const)
    COMMA      [reduce using rule 131 (literal_const)]
    SEMICOLON  reduce using rule 130 (literal_const)
    SEMICOLON  [reduce using rule 131 (literal_const)]
    MR_BRACE   reduce using rule 130 (literal_const)
    MR_BRACE   [reduce using rule 131 (literal_const)]
    R_BRACE    reduce using rule 130 (literal_const)
    R_BRACE    [reduce using rule 131 (literal_const)]
    ADD_OP     reduce using rule 130 (literal_const)
    ADD_OP     [reduce using rule 131 (literal_const)]
    SUB_OP     reduce using rule 130 (literal_const)
    SUB_OP     [reduce using rule 131 (literal_const)]
    MUL_OP     reduce using rule 130 (literal_const)
    MUL_OP     [reduce using rule 131 (literal_const)]
    DIV_OP     reduce using rule 130 (literal_const)
    DIV_OP     [reduce using rule 131 (literal_const)]
    MOD_OP     reduce using rule 130 (literal_const)
    MOD_OP     [reduce using rule 131 (literal_const)]
    LT_OP      reduce using rule 130 (literal_const)
    LT_OP      [reduce using rule 131 (literal_const)]
    GT_OP      reduce using rule 130 (literal_const)
    GT_OP      [reduce using rule 131 (literal_const)]
    $default   reduce using rule 130 (literal_const)


State 93

  132 literal_const: SCIENTIFIC .
  133              | SUB_OP SCIENTIFIC .

    LE_OP      reduce using rule 132 (literal_const)
    LE_OP      [reduce using rule 133 (literal_const)]
    NE_OP      reduce using rule 132 (literal_const)
    NE_OP      [reduce using rule 133 (literal_const)]
    GE_OP      reduce using rule 132 (literal_const)
    GE_OP      [reduce using rule 133 (literal_const)]
    EQ_OP      reduce using rule 132 (literal_const)
    EQ_OP      [reduce using rule 133 (literal_const)]
    AND_OP     reduce using rule 132 (literal_const)
    AND_OP     [reduce using rule 133 (literal_const)]
    OR_OP      reduce using rule 132 (literal_const)
    OR_OP      [reduce using rule 133 (literal_const)]
    R_PAREN    reduce using rule 132 (literal_const)
    R_PAREN    [reduce using rule 133 (literal_const)]
    COMMA      reduce using rule 132 (literal_const)
    COMMA      [reduce using rule 133 (literal_const)]
    SEMICOLON  reduce using rule 132 (literal_const)
    SEMICOLON  [reduce using rule 133 (literal_const)]
    MR_BRACE   reduce using rule 132 (literal_const)
    MR_BRACE   [reduce using rule 133 (literal_const)]
    R_BRACE    reduce using rule 132 (literal_const)
    R_BRACE    [reduce using rule 133 (literal_const)]
    ADD_OP     reduce using rule 132 (literal_const)
    ADD_OP     [reduce using rule 133 (literal_const)]
    SUB_OP     reduce using rule 132 (literal_const)
    SUB_OP     [reduce using rule 133 (literal_const)]
    MUL_OP     reduce using rule 132 (literal_const)
    MUL_OP     [reduce using rule 133 (literal_const)]
    DIV_OP     reduce using rule 132 (literal_const)
    DIV_OP     [reduce using rule 133 (literal_const)]
    MOD_OP     reduce using rule 132 (literal_const)
    MOD_OP     [reduce using rule 133 (literal_const)]
    LT_OP      reduce using rule 132 (literal_const)
    LT_OP      [reduce using rule 133 (literal_const)]
    GT_OP      reduce using rule 132 (literal_const)
    GT_OP      [reduce using rule 133 (literal_const)]
    $default   reduce using rule 132 (literal_const)


State 94

  111 factor: L_PAREN . logical_expression R_PAREN
  112       | SUB_OP L_PAREN . logical_expression R_PAREN

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 133
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 95

  110 factor: SUB_OP factor .

    $default  reduce using rule 110 (factor)


State 96

   91 logical_factor: NOT_OP logical_factor .

    $default  reduce using rule 91 (logical_factor)


State 97

   87 logical_expression: logical_expression OR_OP . logical_term

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_term           go to state 134
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 98

   89 logical_term: logical_term AND_OP . logical_factor

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_factor         go to state 135
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 99

   96 relation_operator: LE_OP .

    $default  reduce using rule 96 (relation_operator)


State 100

  100 relation_operator: NE_OP .

    $default  reduce using rule 100 (relation_operator)


State 101

   98 relation_operator: GE_OP .

    $default  reduce using rule 98 (relation_operator)


State 102

   97 relation_operator: EQ_OP .

    $default  reduce using rule 97 (relation_operator)


State 103

  101 arithmetic_expression: arithmetic_expression ADD_OP . term

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55

    variable_reference  go to state 57
    term                go to state 136
    factor              go to state 64
    array_list          go to state 65
    literal_const       go to state 66


State 104

  102 arithmetic_expression: arithmetic_expression SUB_OP . term

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55

    variable_reference  go to state 57
    term                go to state 137
    factor              go to state 64
    array_list          go to state 65
    literal_const       go to state 66


State 105

   95 relation_operator: LT_OP .

    $default  reduce using rule 95 (relation_operator)


State 106

   99 relation_operator: GT_OP .

    $default  reduce using rule 99 (relation_operator)


State 107

   93 relation_expression: arithmetic_expression relation_operator . arithmetic_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55

    variable_reference     go to state 57
    relation_expression    go to state 138
    arithmetic_expression  go to state 139
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 108

  105 term: term MUL_OP . factor

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55

    variable_reference  go to state 57
    factor              go to state 140
    array_list          go to state 65
    literal_const       go to state 66


State 109

  106 term: term DIV_OP . factor

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55

    variable_reference  go to state 57
    factor              go to state 141
    array_list          go to state 65
    literal_const       go to state 66


State 110

  107 term: term MOD_OP . factor

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55

    variable_reference  go to state 57
    factor              go to state 142
    array_list          go to state 65
    literal_const       go to state 66


State 111

   42 dim: dim ML_BRACE INT_CONST . MR_BRACE

    MR_BRACE  shift, and go to state 143


State 112

   27 identifier_list: identifier_list COMMA ID ASSIGN_OP . logical_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 144
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 113

   28 identifier_list: identifier_list COMMA array_decl ASSIGN_OP . initial_array

    L_BRACE  shift, and go to state 70

    initial_array  go to state 145


State 114

   34 initial_array: L_BRACE literal_list . R_BRACE
   35 literal_list: literal_list . COMMA logical_expression

    COMMA    shift, and go to state 146
    R_BRACE  shift, and go to state 147


State 115

   36 literal_list: logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 36 (literal_list)


State 116

   44 compound_statement: push_table L_BRACE . var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 48 (var_const_stmt_list)

    var_const_stmt_list  go to state 148


State 117

   20 funct_decl: VOID ID L_PAREN parameter_list R_PAREN SEMICOLON .

    $default  reduce using rule 20 (funct_decl)


State 118

   16 funct_def: VOID ID L_PAREN parameter_list R_PAREN compound_statement .

    $default  reduce using rule 16 (funct_def)


State 119

   21 parameter_list: parameter_list COMMA scalar_type . ID
   22               | parameter_list COMMA scalar_type . array_decl

    ID  shift, and go to state 149

    array_decl  go to state 150


State 120

  129 literal_const: SUB_OP INT_CONST .

    $default  reduce using rule 129 (literal_const)


State 121

  131 literal_const: SUB_OP FLOAT_CONST .

    $default  reduce using rule 131 (literal_const)


State 122

  133 literal_const: SUB_OP SCIENTIFIC .

    $default  reduce using rule 133 (literal_const)


State 123

   39 const_list: const_list COMMA ID ASSIGN_OP . literal_const

    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    SUB_OP       shift, and go to state 79

    literal_const  go to state 151


State 124

   18 funct_decl: scalar_type ID L_PAREN parameter_list R_PAREN SEMICOLON .

    $default  reduce using rule 18 (funct_decl)


State 125

   14 funct_def: scalar_type ID L_PAREN parameter_list R_PAREN compound_statement .

    $default  reduce using rule 14 (funct_def)


State 126

  114 factor: ID L_PAREN R_PAREN .

    $default  reduce using rule 114 (factor)


State 127

   87 logical_expression: logical_expression . OR_OP logical_term
  119 logical_expression_list: logical_expression .

    OR_OP  shift, and go to state 97

    $default  reduce using rule 119 (logical_expression_list)


State 128

  113 factor: ID L_PAREN logical_expression_list . R_PAREN
  118 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 152
    COMMA    shift, and go to state 153


State 129

   87 logical_expression: logical_expression . OR_OP logical_term
  122 dimension: ML_BRACE logical_expression . MR_BRACE

    OR_OP     shift, and go to state 97
    MR_BRACE  shift, and go to state 154


State 130

  121 dimension: dimension ML_BRACE . logical_expression MR_BRACE

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 155
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 131

  111 factor: L_PAREN logical_expression R_PAREN .

    $default  reduce using rule 111 (factor)


State 132

  113 factor: ID L_PAREN . logical_expression_list R_PAREN
  114       | ID L_PAREN . R_PAREN
  116       | SUB_OP ID L_PAREN . logical_expression_list R_PAREN
  117       | SUB_OP ID L_PAREN . R_PAREN

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    R_PAREN      shift, and go to state 156
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference       go to state 57
    logical_expression       go to state 127
    logical_term             go to state 59
    logical_factor           go to state 60
    relation_expression      go to state 61
    arithmetic_expression    go to state 62
    term                     go to state 63
    factor                   go to state 64
    logical_expression_list  go to state 157
    array_list               go to state 65
    literal_const            go to state 66


State 133

   87 logical_expression: logical_expression . OR_OP logical_term
  111 factor: L_PAREN logical_expression . R_PAREN
  112       | SUB_OP L_PAREN logical_expression . R_PAREN

    OR_OP    shift, and go to state 97
    R_PAREN  shift, and go to state 158


State 134

   87 logical_expression: logical_expression OR_OP logical_term .
   89 logical_term: logical_term . AND_OP logical_factor

    AND_OP  shift, and go to state 98

    $default  reduce using rule 87 (logical_expression)


State 135

   89 logical_term: logical_term AND_OP logical_factor .

    $default  reduce using rule 89 (logical_term)


State 136

  101 arithmetic_expression: arithmetic_expression ADD_OP term .
  105 term: term . MUL_OP factor
  106     | term . DIV_OP factor
  107     | term . MOD_OP factor

    MUL_OP  shift, and go to state 108
    DIV_OP  shift, and go to state 109
    MOD_OP  shift, and go to state 110

    $default  reduce using rule 101 (arithmetic_expression)


State 137

  102 arithmetic_expression: arithmetic_expression SUB_OP term .
  105 term: term . MUL_OP factor
  106     | term . DIV_OP factor
  107     | term . MOD_OP factor

    MUL_OP  shift, and go to state 108
    DIV_OP  shift, and go to state 109
    MOD_OP  shift, and go to state 110

    $default  reduce using rule 102 (arithmetic_expression)


State 138

  103 arithmetic_expression: relation_expression .

    $default  reduce using rule 103 (arithmetic_expression)


State 139

   93 relation_expression: arithmetic_expression . relation_operator arithmetic_expression
   93                    | arithmetic_expression relation_operator arithmetic_expression .
   94                    | arithmetic_expression .
  101 arithmetic_expression: arithmetic_expression . ADD_OP term
  102                      | arithmetic_expression . SUB_OP term

    LE_OP   shift, and go to state 99
    NE_OP   shift, and go to state 100
    GE_OP   shift, and go to state 101
    EQ_OP   shift, and go to state 102
    ADD_OP  shift, and go to state 103
    SUB_OP  shift, and go to state 104
    LT_OP   shift, and go to state 105
    GT_OP   shift, and go to state 106

    LE_OP      [reduce using rule 93 (relation_expression)]
    LE_OP      [reduce using rule 94 (relation_expression)]
    NE_OP      [reduce using rule 93 (relation_expression)]
    NE_OP      [reduce using rule 94 (relation_expression)]
    GE_OP      [reduce using rule 93 (relation_expression)]
    GE_OP      [reduce using rule 94 (relation_expression)]
    EQ_OP      [reduce using rule 93 (relation_expression)]
    EQ_OP      [reduce using rule 94 (relation_expression)]
    AND_OP     reduce using rule 93 (relation_expression)
    AND_OP     [reduce using rule 94 (relation_expression)]
    OR_OP      reduce using rule 93 (relation_expression)
    OR_OP      [reduce using rule 94 (relation_expression)]
    R_PAREN    reduce using rule 93 (relation_expression)
    R_PAREN    [reduce using rule 94 (relation_expression)]
    COMMA      reduce using rule 93 (relation_expression)
    COMMA      [reduce using rule 94 (relation_expression)]
    SEMICOLON  reduce using rule 93 (relation_expression)
    SEMICOLON  [reduce using rule 94 (relation_expression)]
    MR_BRACE   reduce using rule 93 (relation_expression)
    MR_BRACE   [reduce using rule 94 (relation_expression)]
    R_BRACE    reduce using rule 93 (relation_expression)
    R_BRACE    [reduce using rule 94 (relation_expression)]
    ADD_OP     [reduce using rule 93 (relation_expression)]
    ADD_OP     [reduce using rule 94 (relation_expression)]
    SUB_OP     [reduce using rule 93 (relation_expression)]
    SUB_OP     [reduce using rule 94 (relation_expression)]
    LT_OP      [reduce using rule 93 (relation_expression)]
    LT_OP      [reduce using rule 94 (relation_expression)]
    GT_OP      [reduce using rule 93 (relation_expression)]
    GT_OP      [reduce using rule 94 (relation_expression)]
    $default   reduce using rule 93 (relation_expression)

    relation_operator  go to state 107


State 140

  105 term: term MUL_OP factor .

    $default  reduce using rule 105 (term)


State 141

  106 term: term DIV_OP factor .

    $default  reduce using rule 106 (term)


State 142

  107 term: term MOD_OP factor .

    $default  reduce using rule 107 (term)


State 143

   42 dim: dim ML_BRACE INT_CONST MR_BRACE .

    $default  reduce using rule 42 (dim)


State 144

   27 identifier_list: identifier_list COMMA ID ASSIGN_OP logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 27 (identifier_list)


State 145

   28 identifier_list: identifier_list COMMA array_decl ASSIGN_OP initial_array .

    $default  reduce using rule 28 (identifier_list)


State 146

   35 literal_list: literal_list COMMA . logical_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 159
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 147

   34 initial_array: L_BRACE literal_list R_BRACE .

    $default  reduce using rule 34 (initial_array)


State 148

   44 compound_statement: push_table L_BRACE var_const_stmt_list . R_BRACE pop_table
   45 var_const_stmt_list: var_const_stmt_list . statement
   46                    | var_const_stmt_list . var_decl
   47                    | var_const_stmt_list . const_decl

    ID        shift, and go to state 160
    READ      shift, and go to state 161
    WHILE     shift, and go to state 162
    DO        shift, and go to state 163
    IF        shift, and go to state 164
    FOR       shift, and go to state 165
    INT       shift, and go to state 5
    PRINT     shift, and go to state 166
    BOOL      shift, and go to state 6
    FLOAT     shift, and go to state 8
    DOUBLE    shift, and go to state 9
    STRING    shift, and go to state 10
    CONTINUE  shift, and go to state 167
    BREAK     shift, and go to state 168
    RETURN    shift, and go to state 169
    CONST     shift, and go to state 11
    R_BRACE   shift, and go to state 170

    $default  reduce using rule 1 (push_table)

    push_table                 go to state 73
    var_decl                   go to state 171
    const_decl                 go to state 172
    compound_statement         go to state 173
    statement                  go to state 174
    simple_statement           go to state 175
    conditional_statement      go to state 176
    while_statement            go to state 177
    for_statement              go to state 178
    function_invoke_statement  go to state 179
    jump_statement             go to state 180
    variable_reference         go to state 181
    array_list                 go to state 65
    scalar_type                go to state 182


State 149

   21 parameter_list: parameter_list COMMA scalar_type ID .
   41 array_decl: ID . dim

    ML_BRACE  shift, and go to state 32

    $default  reduce using rule 21 (parameter_list)

    dim  go to state 34


State 150

   22 parameter_list: parameter_list COMMA scalar_type array_decl .

    $default  reduce using rule 22 (parameter_list)


State 151

   39 const_list: const_list COMMA ID ASSIGN_OP literal_const .

    $default  reduce using rule 39 (const_list)


State 152

  113 factor: ID L_PAREN logical_expression_list R_PAREN .

    $default  reduce using rule 113 (factor)


State 153

  118 logical_expression_list: logical_expression_list COMMA . logical_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 183
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 154

  122 dimension: ML_BRACE logical_expression MR_BRACE .

    $default  reduce using rule 122 (dimension)


State 155

   87 logical_expression: logical_expression . OR_OP logical_term
  121 dimension: dimension ML_BRACE logical_expression . MR_BRACE

    OR_OP     shift, and go to state 97
    MR_BRACE  shift, and go to state 184


State 156

  114 factor: ID L_PAREN R_PAREN .
  117       | SUB_OP ID L_PAREN R_PAREN .

    LE_OP      reduce using rule 114 (factor)
    LE_OP      [reduce using rule 117 (factor)]
    NE_OP      reduce using rule 114 (factor)
    NE_OP      [reduce using rule 117 (factor)]
    GE_OP      reduce using rule 114 (factor)
    GE_OP      [reduce using rule 117 (factor)]
    EQ_OP      reduce using rule 114 (factor)
    EQ_OP      [reduce using rule 117 (factor)]
    AND_OP     reduce using rule 114 (factor)
    AND_OP     [reduce using rule 117 (factor)]
    OR_OP      reduce using rule 114 (factor)
    OR_OP      [reduce using rule 117 (factor)]
    R_PAREN    reduce using rule 114 (factor)
    R_PAREN    [reduce using rule 117 (factor)]
    COMMA      reduce using rule 114 (factor)
    COMMA      [reduce using rule 117 (factor)]
    SEMICOLON  reduce using rule 114 (factor)
    SEMICOLON  [reduce using rule 117 (factor)]
    MR_BRACE   reduce using rule 114 (factor)
    MR_BRACE   [reduce using rule 117 (factor)]
    R_BRACE    reduce using rule 114 (factor)
    R_BRACE    [reduce using rule 117 (factor)]
    ADD_OP     reduce using rule 114 (factor)
    ADD_OP     [reduce using rule 117 (factor)]
    SUB_OP     reduce using rule 114 (factor)
    SUB_OP     [reduce using rule 117 (factor)]
    MUL_OP     reduce using rule 114 (factor)
    MUL_OP     [reduce using rule 117 (factor)]
    DIV_OP     reduce using rule 114 (factor)
    DIV_OP     [reduce using rule 117 (factor)]
    MOD_OP     reduce using rule 114 (factor)
    MOD_OP     [reduce using rule 117 (factor)]
    LT_OP      reduce using rule 114 (factor)
    LT_OP      [reduce using rule 117 (factor)]
    GT_OP      reduce using rule 114 (factor)
    GT_OP      [reduce using rule 117 (factor)]
    $default   reduce using rule 114 (factor)


State 157

  113 factor: ID L_PAREN logical_expression_list . R_PAREN
  116       | SUB_OP ID L_PAREN logical_expression_list . R_PAREN
  118 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 185
    COMMA    shift, and go to state 153


State 158

  111 factor: L_PAREN logical_expression R_PAREN .
  112       | SUB_OP L_PAREN logical_expression R_PAREN .

    LE_OP      reduce using rule 111 (factor)
    LE_OP      [reduce using rule 112 (factor)]
    NE_OP      reduce using rule 111 (factor)
    NE_OP      [reduce using rule 112 (factor)]
    GE_OP      reduce using rule 111 (factor)
    GE_OP      [reduce using rule 112 (factor)]
    EQ_OP      reduce using rule 111 (factor)
    EQ_OP      [reduce using rule 112 (factor)]
    AND_OP     reduce using rule 111 (factor)
    AND_OP     [reduce using rule 112 (factor)]
    OR_OP      reduce using rule 111 (factor)
    OR_OP      [reduce using rule 112 (factor)]
    R_PAREN    reduce using rule 111 (factor)
    R_PAREN    [reduce using rule 112 (factor)]
    COMMA      reduce using rule 111 (factor)
    COMMA      [reduce using rule 112 (factor)]
    SEMICOLON  reduce using rule 111 (factor)
    SEMICOLON  [reduce using rule 112 (factor)]
    MR_BRACE   reduce using rule 111 (factor)
    MR_BRACE   [reduce using rule 112 (factor)]
    R_BRACE    reduce using rule 111 (factor)
    R_BRACE    [reduce using rule 112 (factor)]
    ADD_OP     reduce using rule 111 (factor)
    ADD_OP     [reduce using rule 112 (factor)]
    SUB_OP     reduce using rule 111 (factor)
    SUB_OP     [reduce using rule 112 (factor)]
    MUL_OP     reduce using rule 111 (factor)
    MUL_OP     [reduce using rule 112 (factor)]
    DIV_OP     reduce using rule 111 (factor)
    DIV_OP     [reduce using rule 112 (factor)]
    MOD_OP     reduce using rule 111 (factor)
    MOD_OP     [reduce using rule 112 (factor)]
    LT_OP      reduce using rule 111 (factor)
    LT_OP      [reduce using rule 112 (factor)]
    GT_OP      reduce using rule 111 (factor)
    GT_OP      [reduce using rule 112 (factor)]
    $default   reduce using rule 111 (factor)


State 159

   35 literal_list: literal_list COMMA logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 35 (literal_list)


State 160

   80 function_invoke_statement: ID . L_PAREN logical_expression_list R_PAREN SEMICOLON
   81                          | ID . L_PAREN R_PAREN SEMICOLON
   86 variable_reference: ID .
  120 array_list: ID . dimension

    L_PAREN   shift, and go to state 186
    ML_BRACE  shift, and go to state 87

    $default  reduce using rule 86 (variable_reference)

    dimension  go to state 88


State 161

   58 simple_statement: READ . variable_reference SEMICOLON

    ID  shift, and go to state 187

    variable_reference  go to state 188
    array_list          go to state 65


State 162

   64 while_statement: WHILE . L_PAREN logical_expression R_PAREN $@3 push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    L_PAREN  shift, and go to state 189


State 163

   65 while_statement: DO . push_table L_BRACE var_const_stmt_list R_BRACE pop_table WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    $default  reduce using rule 1 (push_table)

    push_table  go to state 190


State 164

   60 conditional_statement: IF . L_PAREN logical_expression R_PAREN $@1 push_table L_BRACE var_const_stmt_list R_BRACE pop_table
   62                      | IF . L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    L_PAREN  shift, and go to state 191


State 165

   66 for_statement: FOR . L_PAREN initial_expression_list SEMICOLON control_expression SEMICOLON increment_expression_list R_PAREN push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    L_PAREN  shift, and go to state 192


State 166

   57 simple_statement: PRINT . logical_expression SEMICOLON

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 193
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 167

   82 jump_statement: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 194


State 168

   83 jump_statement: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 195


State 169

   84 jump_statement: RETURN . logical_expression SEMICOLON

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 196
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 170

   44 compound_statement: push_table L_BRACE var_const_stmt_list R_BRACE . pop_table

    $default  reduce using rule 2 (pop_table)

    pop_table  go to state 197


State 171

   46 var_const_stmt_list: var_const_stmt_list var_decl .

    $default  reduce using rule 46 (var_const_stmt_list)


State 172

   47 var_const_stmt_list: var_const_stmt_list const_decl .

    $default  reduce using rule 47 (var_const_stmt_list)


State 173

   49 statement: compound_statement .

    $default  reduce using rule 49 (statement)


State 174

   45 var_const_stmt_list: var_const_stmt_list statement .

    $default  reduce using rule 45 (var_const_stmt_list)


State 175

   50 statement: simple_statement .

    $default  reduce using rule 50 (statement)


State 176

   51 statement: conditional_statement .

    $default  reduce using rule 51 (statement)


State 177

   52 statement: while_statement .

    $default  reduce using rule 52 (statement)


State 178

   53 statement: for_statement .

    $default  reduce using rule 53 (statement)


State 179

   54 statement: function_invoke_statement .

    $default  reduce using rule 54 (statement)


State 180

   55 statement: jump_statement .

    $default  reduce using rule 55 (statement)


State 181

   56 simple_statement: variable_reference . ASSIGN_OP logical_expression SEMICOLON

    ASSIGN_OP  shift, and go to state 198


State 182

   25 var_decl: scalar_type . identifier_list SEMICOLON

    ID  shift, and go to state 199

    identifier_list  go to state 21
    array_decl       go to state 22


State 183

   87 logical_expression: logical_expression . OR_OP logical_term
  118 logical_expression_list: logical_expression_list COMMA logical_expression .

    OR_OP  shift, and go to state 97

    $default  reduce using rule 118 (logical_expression_list)


State 184

  121 dimension: dimension ML_BRACE logical_expression MR_BRACE .

    $default  reduce using rule 121 (dimension)


State 185

  113 factor: ID L_PAREN logical_expression_list R_PAREN .
  116       | SUB_OP ID L_PAREN logical_expression_list R_PAREN .

    LE_OP      reduce using rule 113 (factor)
    LE_OP      [reduce using rule 116 (factor)]
    NE_OP      reduce using rule 113 (factor)
    NE_OP      [reduce using rule 116 (factor)]
    GE_OP      reduce using rule 113 (factor)
    GE_OP      [reduce using rule 116 (factor)]
    EQ_OP      reduce using rule 113 (factor)
    EQ_OP      [reduce using rule 116 (factor)]
    AND_OP     reduce using rule 113 (factor)
    AND_OP     [reduce using rule 116 (factor)]
    OR_OP      reduce using rule 113 (factor)
    OR_OP      [reduce using rule 116 (factor)]
    R_PAREN    reduce using rule 113 (factor)
    R_PAREN    [reduce using rule 116 (factor)]
    COMMA      reduce using rule 113 (factor)
    COMMA      [reduce using rule 116 (factor)]
    SEMICOLON  reduce using rule 113 (factor)
    SEMICOLON  [reduce using rule 116 (factor)]
    MR_BRACE   reduce using rule 113 (factor)
    MR_BRACE   [reduce using rule 116 (factor)]
    R_BRACE    reduce using rule 113 (factor)
    R_BRACE    [reduce using rule 116 (factor)]
    ADD_OP     reduce using rule 113 (factor)
    ADD_OP     [reduce using rule 116 (factor)]
    SUB_OP     reduce using rule 113 (factor)
    SUB_OP     [reduce using rule 116 (factor)]
    MUL_OP     reduce using rule 113 (factor)
    MUL_OP     [reduce using rule 116 (factor)]
    DIV_OP     reduce using rule 113 (factor)
    DIV_OP     [reduce using rule 116 (factor)]
    MOD_OP     reduce using rule 113 (factor)
    MOD_OP     [reduce using rule 116 (factor)]
    LT_OP      reduce using rule 113 (factor)
    LT_OP      [reduce using rule 116 (factor)]
    GT_OP      reduce using rule 113 (factor)
    GT_OP      [reduce using rule 116 (factor)]
    $default   reduce using rule 113 (factor)


State 186

   80 function_invoke_statement: ID L_PAREN . logical_expression_list R_PAREN SEMICOLON
   81                          | ID L_PAREN . R_PAREN SEMICOLON

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    R_PAREN      shift, and go to state 200
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference       go to state 57
    logical_expression       go to state 127
    logical_term             go to state 59
    logical_factor           go to state 60
    relation_expression      go to state 61
    arithmetic_expression    go to state 62
    term                     go to state 63
    factor                   go to state 64
    logical_expression_list  go to state 201
    array_list               go to state 65
    literal_const            go to state 66


State 187

   86 variable_reference: ID .
  120 array_list: ID . dimension

    ML_BRACE  shift, and go to state 87

    $default  reduce using rule 86 (variable_reference)

    dimension  go to state 88


State 188

   58 simple_statement: READ variable_reference . SEMICOLON

    SEMICOLON  shift, and go to state 202


State 189

   64 while_statement: WHILE L_PAREN . logical_expression R_PAREN $@3 push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 203
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 190

   65 while_statement: DO push_table . L_BRACE var_const_stmt_list R_BRACE pop_table WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    L_BRACE  shift, and go to state 204


State 191

   60 conditional_statement: IF L_PAREN . logical_expression R_PAREN $@1 push_table L_BRACE var_const_stmt_list R_BRACE pop_table
   62                      | IF L_PAREN . logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 205
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 192

   66 for_statement: FOR L_PAREN . initial_expression_list SEMICOLON control_expression SEMICOLON increment_expression_list R_PAREN push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    $default  reduce using rule 68 (initial_expression_list)

    initial_expression_list  go to state 206
    initial_expression       go to state 207
    variable_reference       go to state 208
    logical_expression       go to state 209
    logical_term             go to state 59
    logical_factor           go to state 60
    relation_expression      go to state 61
    arithmetic_expression    go to state 62
    term                     go to state 63
    factor                   go to state 64
    array_list               go to state 65
    literal_const            go to state 66


State 193

   57 simple_statement: PRINT logical_expression . SEMICOLON
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 97
    SEMICOLON  shift, and go to state 210


State 194

   82 jump_statement: CONTINUE SEMICOLON .

    $default  reduce using rule 82 (jump_statement)


State 195

   83 jump_statement: BREAK SEMICOLON .

    $default  reduce using rule 83 (jump_statement)


State 196

   84 jump_statement: RETURN logical_expression . SEMICOLON
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 97
    SEMICOLON  shift, and go to state 211


State 197

   44 compound_statement: push_table L_BRACE var_const_stmt_list R_BRACE pop_table .

    $default  reduce using rule 44 (compound_statement)


State 198

   56 simple_statement: variable_reference ASSIGN_OP . logical_expression SEMICOLON

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 212
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 199

   32 identifier_list: ID . ASSIGN_OP logical_expression
   33                | ID .
   41 array_decl: ID . dim

    ML_BRACE   shift, and go to state 32
    ASSIGN_OP  shift, and go to state 33

    $default  reduce using rule 33 (identifier_list)

    dim  go to state 34


State 200

   81 function_invoke_statement: ID L_PAREN R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 213


State 201

   80 function_invoke_statement: ID L_PAREN logical_expression_list . R_PAREN SEMICOLON
  118 logical_expression_list: logical_expression_list . COMMA logical_expression

    R_PAREN  shift, and go to state 214
    COMMA    shift, and go to state 153


State 202

   58 simple_statement: READ variable_reference SEMICOLON .

    $default  reduce using rule 58 (simple_statement)


State 203

   64 while_statement: WHILE L_PAREN logical_expression . R_PAREN $@3 push_table L_BRACE var_const_stmt_list R_BRACE pop_table
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP    shift, and go to state 97
    R_PAREN  shift, and go to state 215


State 204

   65 while_statement: DO push_table L_BRACE . var_const_stmt_list R_BRACE pop_table WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    $default  reduce using rule 48 (var_const_stmt_list)

    var_const_stmt_list  go to state 216


State 205

   60 conditional_statement: IF L_PAREN logical_expression . R_PAREN $@1 push_table L_BRACE var_const_stmt_list R_BRACE pop_table
   62                      | IF L_PAREN logical_expression . R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP    shift, and go to state 97
    R_PAREN  shift, and go to state 217


State 206

   66 for_statement: FOR L_PAREN initial_expression_list . SEMICOLON control_expression SEMICOLON increment_expression_list R_PAREN push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    SEMICOLON  shift, and go to state 218


State 207

   67 initial_expression_list: initial_expression .
   69 initial_expression: initial_expression . COMMA variable_reference ASSIGN_OP logical_expression
   70                   | initial_expression . COMMA logical_expression

    COMMA  shift, and go to state 219

    $default  reduce using rule 67 (initial_expression_list)


State 208

   72 initial_expression: variable_reference . ASSIGN_OP logical_expression
  109 factor: variable_reference .

    ASSIGN_OP  shift, and go to state 220

    $default  reduce using rule 109 (factor)


State 209

   71 initial_expression: logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 71 (initial_expression)


State 210

   57 simple_statement: PRINT logical_expression SEMICOLON .

    $default  reduce using rule 57 (simple_statement)


State 211

   84 jump_statement: RETURN logical_expression SEMICOLON .

    $default  reduce using rule 84 (jump_statement)


State 212

   56 simple_statement: variable_reference ASSIGN_OP logical_expression . SEMICOLON
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP      shift, and go to state 97
    SEMICOLON  shift, and go to state 221


State 213

   81 function_invoke_statement: ID L_PAREN R_PAREN SEMICOLON .

    $default  reduce using rule 81 (function_invoke_statement)


State 214

   80 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 222


State 215

   64 while_statement: WHILE L_PAREN logical_expression R_PAREN . $@3 push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 63 ($@3)

    $@3  go to state 223


State 216

   45 var_const_stmt_list: var_const_stmt_list . statement
   46                    | var_const_stmt_list . var_decl
   47                    | var_const_stmt_list . const_decl
   65 while_statement: DO push_table L_BRACE var_const_stmt_list . R_BRACE pop_table WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    ID        shift, and go to state 160
    READ      shift, and go to state 161
    WHILE     shift, and go to state 162
    DO        shift, and go to state 163
    IF        shift, and go to state 164
    FOR       shift, and go to state 165
    INT       shift, and go to state 5
    PRINT     shift, and go to state 166
    BOOL      shift, and go to state 6
    FLOAT     shift, and go to state 8
    DOUBLE    shift, and go to state 9
    STRING    shift, and go to state 10
    CONTINUE  shift, and go to state 167
    BREAK     shift, and go to state 168
    RETURN    shift, and go to state 169
    CONST     shift, and go to state 11
    R_BRACE   shift, and go to state 224

    $default  reduce using rule 1 (push_table)

    push_table                 go to state 73
    var_decl                   go to state 171
    const_decl                 go to state 172
    compound_statement         go to state 173
    statement                  go to state 174
    simple_statement           go to state 175
    conditional_statement      go to state 176
    while_statement            go to state 177
    for_statement              go to state 178
    function_invoke_statement  go to state 179
    jump_statement             go to state 180
    variable_reference         go to state 181
    array_list                 go to state 65
    scalar_type                go to state 182


State 217

   60 conditional_statement: IF L_PAREN logical_expression R_PAREN . $@1 push_table L_BRACE var_const_stmt_list R_BRACE pop_table
   62                      | IF L_PAREN logical_expression R_PAREN . $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    L_BRACE   reduce using rule 59 ($@1)
    L_BRACE   [reduce using rule 61 ($@2)]
    $default  reduce using rule 59 ($@1)

    $@1  go to state 225
    $@2  go to state 226


State 218

   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON . control_expression SEMICOLON increment_expression_list R_PAREN push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    control_expression     go to state 227
    variable_reference     go to state 57
    logical_expression     go to state 228
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 219

   69 initial_expression: initial_expression COMMA . variable_reference ASSIGN_OP logical_expression
   70                   | initial_expression COMMA . logical_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 229
    logical_expression     go to state 230
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 220

   72 initial_expression: variable_reference ASSIGN_OP . logical_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 231
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 221

   56 simple_statement: variable_reference ASSIGN_OP logical_expression SEMICOLON .

    $default  reduce using rule 56 (simple_statement)


State 222

   80 function_invoke_statement: ID L_PAREN logical_expression_list R_PAREN SEMICOLON .

    $default  reduce using rule 80 (function_invoke_statement)


State 223

   64 while_statement: WHILE L_PAREN logical_expression R_PAREN $@3 . push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 1 (push_table)

    push_table  go to state 232


State 224

   65 while_statement: DO push_table L_BRACE var_const_stmt_list R_BRACE . pop_table WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    $default  reduce using rule 2 (pop_table)

    pop_table  go to state 233


State 225

   60 conditional_statement: IF L_PAREN logical_expression R_PAREN $@1 . push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 1 (push_table)

    push_table  go to state 234


State 226

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 . push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 1 (push_table)

    push_table  go to state 235


State 227

   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON control_expression . SEMICOLON increment_expression_list R_PAREN push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    SEMICOLON  shift, and go to state 236


State 228

   73 control_expression: logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 73 (control_expression)


State 229

   69 initial_expression: initial_expression COMMA variable_reference . ASSIGN_OP logical_expression
  109 factor: variable_reference .

    ASSIGN_OP  shift, and go to state 237

    $default  reduce using rule 109 (factor)


State 230

   70 initial_expression: initial_expression COMMA logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 70 (initial_expression)


State 231

   72 initial_expression: variable_reference ASSIGN_OP logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 72 (initial_expression)


State 232

   64 while_statement: WHILE L_PAREN logical_expression R_PAREN $@3 push_table . L_BRACE var_const_stmt_list R_BRACE pop_table

    L_BRACE  shift, and go to state 238


State 233

   65 while_statement: DO push_table L_BRACE var_const_stmt_list R_BRACE pop_table . WHILE L_PAREN logical_expression R_PAREN SEMICOLON

    WHILE  shift, and go to state 239


State 234

   60 conditional_statement: IF L_PAREN logical_expression R_PAREN $@1 push_table . L_BRACE var_const_stmt_list R_BRACE pop_table

    L_BRACE  shift, and go to state 240


State 235

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table . L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    L_BRACE  shift, and go to state 241


State 236

   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON control_expression SEMICOLON . increment_expression_list R_PAREN push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    $default  reduce using rule 75 (increment_expression_list)

    increment_expression_list  go to state 242
    increment_expression       go to state 243
    variable_reference         go to state 244
    logical_expression         go to state 245
    logical_term               go to state 59
    logical_factor             go to state 60
    relation_expression        go to state 61
    arithmetic_expression      go to state 62
    term                       go to state 63
    factor                     go to state 64
    array_list                 go to state 65
    literal_const              go to state 66


State 237

   69 initial_expression: initial_expression COMMA variable_reference ASSIGN_OP . logical_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 246
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 238

   64 while_statement: WHILE L_PAREN logical_expression R_PAREN $@3 push_table L_BRACE . var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 48 (var_const_stmt_list)

    var_const_stmt_list  go to state 247


State 239

   65 while_statement: DO push_table L_BRACE var_const_stmt_list R_BRACE pop_table WHILE . L_PAREN logical_expression R_PAREN SEMICOLON

    L_PAREN  shift, and go to state 248


State 240

   60 conditional_statement: IF L_PAREN logical_expression R_PAREN $@1 push_table L_BRACE . var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 48 (var_const_stmt_list)

    var_const_stmt_list  go to state 249


State 241

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE . var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 48 (var_const_stmt_list)

    var_const_stmt_list  go to state 250


State 242

   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON control_expression SEMICOLON increment_expression_list . R_PAREN push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    R_PAREN  shift, and go to state 251


State 243

   74 increment_expression_list: increment_expression .
   76 increment_expression: increment_expression . COMMA variable_reference ASSIGN_OP logical_expression
   77                     | increment_expression . COMMA logical_expression

    COMMA  shift, and go to state 252

    $default  reduce using rule 74 (increment_expression_list)


State 244

   79 increment_expression: variable_reference . ASSIGN_OP logical_expression
  109 factor: variable_reference .

    ASSIGN_OP  shift, and go to state 253

    $default  reduce using rule 109 (factor)


State 245

   78 increment_expression: logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 78 (increment_expression)


State 246

   69 initial_expression: initial_expression COMMA variable_reference ASSIGN_OP logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 69 (initial_expression)


State 247

   45 var_const_stmt_list: var_const_stmt_list . statement
   46                    | var_const_stmt_list . var_decl
   47                    | var_const_stmt_list . const_decl
   64 while_statement: WHILE L_PAREN logical_expression R_PAREN $@3 push_table L_BRACE var_const_stmt_list . R_BRACE pop_table

    ID        shift, and go to state 160
    READ      shift, and go to state 161
    WHILE     shift, and go to state 162
    DO        shift, and go to state 163
    IF        shift, and go to state 164
    FOR       shift, and go to state 165
    INT       shift, and go to state 5
    PRINT     shift, and go to state 166
    BOOL      shift, and go to state 6
    FLOAT     shift, and go to state 8
    DOUBLE    shift, and go to state 9
    STRING    shift, and go to state 10
    CONTINUE  shift, and go to state 167
    BREAK     shift, and go to state 168
    RETURN    shift, and go to state 169
    CONST     shift, and go to state 11
    R_BRACE   shift, and go to state 254

    $default  reduce using rule 1 (push_table)

    push_table                 go to state 73
    var_decl                   go to state 171
    const_decl                 go to state 172
    compound_statement         go to state 173
    statement                  go to state 174
    simple_statement           go to state 175
    conditional_statement      go to state 176
    while_statement            go to state 177
    for_statement              go to state 178
    function_invoke_statement  go to state 179
    jump_statement             go to state 180
    variable_reference         go to state 181
    array_list                 go to state 65
    scalar_type                go to state 182


State 248

   65 while_statement: DO push_table L_BRACE var_const_stmt_list R_BRACE pop_table WHILE L_PAREN . logical_expression R_PAREN SEMICOLON

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 255
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 249

   45 var_const_stmt_list: var_const_stmt_list . statement
   46                    | var_const_stmt_list . var_decl
   47                    | var_const_stmt_list . const_decl
   60 conditional_statement: IF L_PAREN logical_expression R_PAREN $@1 push_table L_BRACE var_const_stmt_list . R_BRACE pop_table

    ID        shift, and go to state 160
    READ      shift, and go to state 161
    WHILE     shift, and go to state 162
    DO        shift, and go to state 163
    IF        shift, and go to state 164
    FOR       shift, and go to state 165
    INT       shift, and go to state 5
    PRINT     shift, and go to state 166
    BOOL      shift, and go to state 6
    FLOAT     shift, and go to state 8
    DOUBLE    shift, and go to state 9
    STRING    shift, and go to state 10
    CONTINUE  shift, and go to state 167
    BREAK     shift, and go to state 168
    RETURN    shift, and go to state 169
    CONST     shift, and go to state 11
    R_BRACE   shift, and go to state 256

    $default  reduce using rule 1 (push_table)

    push_table                 go to state 73
    var_decl                   go to state 171
    const_decl                 go to state 172
    compound_statement         go to state 173
    statement                  go to state 174
    simple_statement           go to state 175
    conditional_statement      go to state 176
    while_statement            go to state 177
    for_statement              go to state 178
    function_invoke_statement  go to state 179
    jump_statement             go to state 180
    variable_reference         go to state 181
    array_list                 go to state 65
    scalar_type                go to state 182


State 250

   45 var_const_stmt_list: var_const_stmt_list . statement
   46                    | var_const_stmt_list . var_decl
   47                    | var_const_stmt_list . const_decl
   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list . R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    ID        shift, and go to state 160
    READ      shift, and go to state 161
    WHILE     shift, and go to state 162
    DO        shift, and go to state 163
    IF        shift, and go to state 164
    FOR       shift, and go to state 165
    INT       shift, and go to state 5
    PRINT     shift, and go to state 166
    BOOL      shift, and go to state 6
    FLOAT     shift, and go to state 8
    DOUBLE    shift, and go to state 9
    STRING    shift, and go to state 10
    CONTINUE  shift, and go to state 167
    BREAK     shift, and go to state 168
    RETURN    shift, and go to state 169
    CONST     shift, and go to state 11
    R_BRACE   shift, and go to state 257

    $default  reduce using rule 1 (push_table)

    push_table                 go to state 73
    var_decl                   go to state 171
    const_decl                 go to state 172
    compound_statement         go to state 173
    statement                  go to state 174
    simple_statement           go to state 175
    conditional_statement      go to state 176
    while_statement            go to state 177
    for_statement              go to state 178
    function_invoke_statement  go to state 179
    jump_statement             go to state 180
    variable_reference         go to state 181
    array_list                 go to state 65
    scalar_type                go to state 182


State 251

   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON control_expression SEMICOLON increment_expression_list R_PAREN . push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 1 (push_table)

    push_table  go to state 258


State 252

   76 increment_expression: increment_expression COMMA . variable_reference ASSIGN_OP logical_expression
   77                     | increment_expression COMMA . logical_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 259
    logical_expression     go to state 260
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 253

   79 increment_expression: variable_reference ASSIGN_OP . logical_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 261
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 254

   64 while_statement: WHILE L_PAREN logical_expression R_PAREN $@3 push_table L_BRACE var_const_stmt_list R_BRACE . pop_table

    $default  reduce using rule 2 (pop_table)

    pop_table  go to state 262


State 255

   65 while_statement: DO push_table L_BRACE var_const_stmt_list R_BRACE pop_table WHILE L_PAREN logical_expression . R_PAREN SEMICOLON
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP    shift, and go to state 97
    R_PAREN  shift, and go to state 263


State 256

   60 conditional_statement: IF L_PAREN logical_expression R_PAREN $@1 push_table L_BRACE var_const_stmt_list R_BRACE . pop_table

    $default  reduce using rule 2 (pop_table)

    pop_table  go to state 264


State 257

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE . pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 2 (pop_table)

    pop_table  go to state 265


State 258

   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON control_expression SEMICOLON increment_expression_list R_PAREN push_table . L_BRACE var_const_stmt_list R_BRACE pop_table

    L_BRACE  shift, and go to state 266


State 259

   76 increment_expression: increment_expression COMMA variable_reference . ASSIGN_OP logical_expression
  109 factor: variable_reference .

    ASSIGN_OP  shift, and go to state 267

    $default  reduce using rule 109 (factor)


State 260

   77 increment_expression: increment_expression COMMA logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 77 (increment_expression)


State 261

   79 increment_expression: variable_reference ASSIGN_OP logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 79 (increment_expression)


State 262

   64 while_statement: WHILE L_PAREN logical_expression R_PAREN $@3 push_table L_BRACE var_const_stmt_list R_BRACE pop_table .

    $default  reduce using rule 64 (while_statement)


State 263

   65 while_statement: DO push_table L_BRACE var_const_stmt_list R_BRACE pop_table WHILE L_PAREN logical_expression R_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 268


State 264

   60 conditional_statement: IF L_PAREN logical_expression R_PAREN $@1 push_table L_BRACE var_const_stmt_list R_BRACE pop_table .

    $default  reduce using rule 60 (conditional_statement)


State 265

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table . ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    ELSE  shift, and go to state 269


State 266

   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON control_expression SEMICOLON increment_expression_list R_PAREN push_table L_BRACE . var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 48 (var_const_stmt_list)

    var_const_stmt_list  go to state 270


State 267

   76 increment_expression: increment_expression COMMA variable_reference ASSIGN_OP . logical_expression

    ID           shift, and go to state 47
    INT_CONST    shift, and go to state 48
    FLOAT_CONST  shift, and go to state 49
    SCIENTIFIC   shift, and go to state 50
    STR_CONST    shift, and go to state 51
    TRUE         shift, and go to state 52
    FALSE        shift, and go to state 53
    L_PAREN      shift, and go to state 54
    SUB_OP       shift, and go to state 55
    NOT_OP       shift, and go to state 56

    variable_reference     go to state 57
    logical_expression     go to state 271
    logical_term           go to state 59
    logical_factor         go to state 60
    relation_expression    go to state 61
    arithmetic_expression  go to state 62
    term                   go to state 63
    factor                 go to state 64
    array_list             go to state 65
    literal_const          go to state 66


State 268

   65 while_statement: DO push_table L_BRACE var_const_stmt_list R_BRACE pop_table WHILE L_PAREN logical_expression R_PAREN SEMICOLON .

    $default  reduce using rule 65 (while_statement)


State 269

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE . push_table L_BRACE var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 1 (push_table)

    push_table  go to state 272


State 270

   45 var_const_stmt_list: var_const_stmt_list . statement
   46                    | var_const_stmt_list . var_decl
   47                    | var_const_stmt_list . const_decl
   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON control_expression SEMICOLON increment_expression_list R_PAREN push_table L_BRACE var_const_stmt_list . R_BRACE pop_table

    ID        shift, and go to state 160
    READ      shift, and go to state 161
    WHILE     shift, and go to state 162
    DO        shift, and go to state 163
    IF        shift, and go to state 164
    FOR       shift, and go to state 165
    INT       shift, and go to state 5
    PRINT     shift, and go to state 166
    BOOL      shift, and go to state 6
    FLOAT     shift, and go to state 8
    DOUBLE    shift, and go to state 9
    STRING    shift, and go to state 10
    CONTINUE  shift, and go to state 167
    BREAK     shift, and go to state 168
    RETURN    shift, and go to state 169
    CONST     shift, and go to state 11
    R_BRACE   shift, and go to state 273

    $default  reduce using rule 1 (push_table)

    push_table                 go to state 73
    var_decl                   go to state 171
    const_decl                 go to state 172
    compound_statement         go to state 173
    statement                  go to state 174
    simple_statement           go to state 175
    conditional_statement      go to state 176
    while_statement            go to state 177
    for_statement              go to state 178
    function_invoke_statement  go to state 179
    jump_statement             go to state 180
    variable_reference         go to state 181
    array_list                 go to state 65
    scalar_type                go to state 182


State 271

   76 increment_expression: increment_expression COMMA variable_reference ASSIGN_OP logical_expression .
   87 logical_expression: logical_expression . OR_OP logical_term

    OR_OP  shift, and go to state 97

    $default  reduce using rule 76 (increment_expression)


State 272

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table . L_BRACE var_const_stmt_list R_BRACE pop_table

    L_BRACE  shift, and go to state 274


State 273

   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON control_expression SEMICOLON increment_expression_list R_PAREN push_table L_BRACE var_const_stmt_list R_BRACE . pop_table

    $default  reduce using rule 2 (pop_table)

    pop_table  go to state 275


State 274

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE . var_const_stmt_list R_BRACE pop_table

    $default  reduce using rule 48 (var_const_stmt_list)

    var_const_stmt_list  go to state 276


State 275

   66 for_statement: FOR L_PAREN initial_expression_list SEMICOLON control_expression SEMICOLON increment_expression_list R_PAREN push_table L_BRACE var_const_stmt_list R_BRACE pop_table .

    $default  reduce using rule 66 (for_statement)


State 276

   45 var_const_stmt_list: var_const_stmt_list . statement
   46                    | var_const_stmt_list . var_decl
   47                    | var_const_stmt_list . const_decl
   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list . R_BRACE pop_table

    ID        shift, and go to state 160
    READ      shift, and go to state 161
    WHILE     shift, and go to state 162
    DO        shift, and go to state 163
    IF        shift, and go to state 164
    FOR       shift, and go to state 165
    INT       shift, and go to state 5
    PRINT     shift, and go to state 166
    BOOL      shift, and go to state 6
    FLOAT     shift, and go to state 8
    DOUBLE    shift, and go to state 9
    STRING    shift, and go to state 10
    CONTINUE  shift, and go to state 167
    BREAK     shift, and go to state 168
    RETURN    shift, and go to state 169
    CONST     shift, and go to state 11
    R_BRACE   shift, and go to state 277

    $default  reduce using rule 1 (push_table)

    push_table                 go to state 73
    var_decl                   go to state 171
    const_decl                 go to state 172
    compound_statement         go to state 173
    statement                  go to state 174
    simple_statement           go to state 175
    conditional_statement      go to state 176
    while_statement            go to state 177
    for_statement              go to state 178
    function_invoke_statement  go to state 179
    jump_statement             go to state 180
    variable_reference         go to state 181
    array_list                 go to state 65
    scalar_type                go to state 182


State 277

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE . pop_table

    $default  reduce using rule 2 (pop_table)

    pop_table  go to state 278


State 278

   62 conditional_statement: IF L_PAREN logical_expression R_PAREN $@2 push_table L_BRACE var_const_stmt_list R_BRACE pop_table ELSE push_table L_BRACE var_const_stmt_list R_BRACE pop_table .

    $default  reduce using rule 62 (conditional_statement)
